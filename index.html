<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MOONAD // moonad.fun</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&family=VT323&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0a;
      --primary: #33ff00;
      --secondary: #ffb000;
      --muted: #1f521f;
      --error: #ff3333;
      --border: #1f521f;
      --font: 'JetBrains Mono', 'Fira Code', monospace;
      --font-retro: 'VT323', monospace;
      --glow: 0 0 5px rgba(51, 255, 0, 0.5);
      --glow-strong: 0 0 10px rgba(51, 255, 0, 0.7), 0 0 20px rgba(51, 255, 0, 0.3);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: var(--bg); font-family: var(--font); }
    canvas { display: block; }

    /* CRT Scanline overlay */
    #crt-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 100;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.08) 2px,
        rgba(0, 0, 0, 0.08) 4px
      );
    }
    #crt-overlay::after {
      content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.4) 100%);
    }

    #hud {
      position: absolute; top: 0; left: 0; width: 100%; pointer-events: none;
      font-family: var(--font); z-index: 50;
    }

    /* Title bar — like a terminal window header */
    #title-bar {
      display: flex; justify-content: space-between; align-items: center;
      padding: 6px 12px;
      background: rgba(10, 10, 10, 0.85);
      border-bottom: 1px solid var(--muted);
      font-size: 11px; color: var(--primary);
      text-shadow: var(--glow);
    }
    #title-bar .sys { color: var(--muted); }
    #title-bar .title-text { letter-spacing: 2px; font-weight: 700; }

    /* Leaderboard — terminal pane */
    #leaderboard {
      position: absolute; top: 35px; right: 10px;
      background: rgba(10, 10, 10, 0.9);
      border: 1px solid var(--muted);
      border-radius: 0;
      padding: 0; min-width: 240px;
      color: var(--primary); font-size: 11px; line-height: 1;
      text-shadow: var(--glow);
    }
    #lb-header {
      padding: 4px 8px;
      background: var(--primary); color: var(--bg);
      font-weight: 700; font-size: 10px; letter-spacing: 1px;
      text-shadow: none;
    }
    #lb-body { padding: 6px 8px; }
    #leaderboard .lane {
      display: flex; align-items: center; gap: 4px;
      padding: 2px 0; font-size: 11px;
      border-bottom: 1px solid rgba(31, 82, 31, 0.3);
    }
    #leaderboard .lane:last-child { border-bottom: none; }
    #leaderboard .dot {
      width: 6px; height: 6px; border-radius: 0; display: inline-block; flex-shrink: 0;
    }
    #leaderboard .pos { font-weight: 700; width: 20px; color: var(--muted); }
    #leaderboard .name-text { flex: 1; }
    #leaderboard .medal { color: var(--secondary); }
    #leaderboard .done { color: var(--primary); font-size: 9px; }

    /* Race stats bar — bottom (fixed to viewport) */
    #stats-bar {
      position: fixed; bottom: 0; left: 0; width: 100%;
      padding: 5px 12px;
      background: rgba(10, 10, 10, 0.85);
      border-top: 1px solid var(--muted);
      font-size: 10px; color: var(--muted);
      display: flex; justify-content: space-between;
      text-shadow: var(--glow);
      z-index: 50; pointer-events: none;
    }
    #stats-bar .active { color: var(--primary); }
    #stats-bar .warn { color: var(--secondary); }

    /* Loading screen */
    #loading {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: var(--primary); font-family: var(--font); font-size: 14px;
      text-shadow: var(--glow-strong);
    }
    #loading::after {
      content: '_'; animation: blink 0.6s step-end infinite;
    }
    #loading.lfg {
      font-size: 20vw; font-weight: 800; letter-spacing: 0.05em;
      color: var(--secondary);
      text-shadow: 0 0 30px rgba(255, 176, 0, 0.8), 0 0 60px rgba(255, 176, 0, 0.4);
    }
    #loading.lfg::after { content: ''; }
    @keyframes blink {
      0%, 100% { opacity: 1; } 50% { opacity: 0; }
    }

    /* Winner announcement — terminal alert */
    #winner {
      display: none; position: fixed; bottom: 40px; right: 10px;
      background: var(--bg);
      color: var(--secondary);
      font-family: var(--font); font-size: 16px;
      padding: 0; border: 1px solid var(--secondary);
      border-radius: 0; text-align: left;
      text-shadow: 0 0 8px rgba(255, 176, 0, 0.6);
      min-width: 280px; z-index: 60;
    }
    #winner-header {
      padding: 4px 8px;
      background: var(--secondary); color: var(--bg);
      font-weight: 700; font-size: 10px; letter-spacing: 1px;
      display: flex; justify-content: space-between; align-items: center;
    }
    #winner-close {
      cursor: pointer; pointer-events: auto;
      background: none; border: 1px solid var(--bg); color: var(--bg);
      font-family: var(--font); font-size: 12px; font-weight: 700;
      padding: 0 4px; line-height: 1.4;
    }
    #winner-close:hover { background: var(--bg); color: var(--secondary); }
    #winner-body {
      padding: 16px;
    }
    #winner .name {
      font-weight: 800; letter-spacing: 2px;
    }
    #winner .prompt { color: var(--muted); font-size: 11px; margin-top: 10px; }

    /* Countdown */
    #countdown {
      display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: var(--primary); font-family: var(--font-retro); font-size: 120px;
      text-shadow: var(--glow-strong);
      z-index: 60;
    }
    #countdown.go { color: var(--secondary); text-shadow: 0 0 15px rgba(255,176,0,0.7); }

    /* Camera mode controls */
    #cam-controls {
      position: fixed; bottom: 28px; left: 10px;
      display: flex; gap: 4px; z-index: 50;
    }
    #cam-controls button {
      background: rgba(10, 10, 10, 0.9);
      border: 1px solid var(--muted);
      color: var(--muted);
      font-family: var(--font);
      font-size: 10px;
      padding: 3px 8px;
      cursor: pointer;
      letter-spacing: 1px;
      pointer-events: auto;
    }
    #cam-controls button:hover {
      border-color: var(--primary);
      color: var(--primary);
    }
    #cam-controls button.active {
      background: var(--primary);
      color: var(--bg);
      border-color: var(--primary);
      text-shadow: none;
    }

    /* Winner photo & stats */
    #winner-photo {
      border: 1px solid var(--secondary);
      width: 100%;
      display: block;
      margin-bottom: 8px;
    }
    #winner .stats {
      color: var(--secondary);
      font-size: 11px;
      line-height: 1.8;
      white-space: pre;
    }
  </style>
</head>
<body>
  <div id="crt-overlay"></div>
  <div id="hud">
    <div id="title-bar">
      <span class="sys">[SYS]</span>
      <span class="title-text">&gt; MOONAD // 500M SPRINT</span>
      <span class="sys" id="clock-display">00:00.0</span>
    </div>
    <div id="leaderboard">
      <div id="lb-header">+-- LEADERBOARD --+</div>
      <div id="lb-body"></div>
    </div>
  </div>
  <div id="stats-bar">
    <span class="active" id="track-info">&gt; TRACK: 500M | 8 BULLS</span>
    <span id="speed-info" class="warn">SPD: --.- M/S</span>
    <span class="sys" id="cam-mode-info">CAM: CHASE</span>
  </div>
  <div id="cam-controls">
    <button data-mode="free">FREE</button>
    <button data-mode="top">TOP</button>
    <button data-mode="side">SIDE</button>
    <button data-mode="front">FRONT</button>
    <button data-mode="chase" class="active">CHASE</button>
  </div>
  <div id="loading">&gt; initializing_bull_run</div>
  <div id="winner">
    <div id="winner-header"><span>+-- RACE COMPLETE --+</span><button id="winner-close" onclick="document.getElementById('winner').style.display='none'">[X]</button></div>
    <div id="winner-body"></div>
  </div>
  <div id="countdown"></div>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

    const NUM_BULLS = 8;
    const LANE_WIDTH = 2.4;
    const FINISH_X = 500;  // 500 meters

    // Terminal wireframe colors — all green/amber spectrum
    const bullColors = [
      { name: 'Crimson Thunder', wire: 0xff3333, dot: '#ff3333' },
      { name: 'Midnight Storm',  wire: 0x33ccff, dot: '#33ccff' },
      { name: 'Scarlet Blaze',   wire: 0xff6600, dot: '#ff6600' },
      { name: 'Emerald Fury',    wire: 0x33ff00, dot: '#33ff00' },
      { name: 'Golden Horns',    wire: 0xffb000, dot: '#ffb000' },
      { name: 'Silver Bullet',   wire: 0xcccccc, dot: '#cccccc' },
      { name: 'Violet Charge',   wire: 0xcc33ff, dot: '#cc33ff' },
      { name: 'Copper Beast',    wire: 0xff9933, dot: '#ff9933' },
    ];

    // ======== SCENE ========
    const scene = new THREE.Scene();

    // Pure black background — terminal void
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.004);

    // Wider FOV for speed sensation
    const camera = new THREE.PerspectiveCamera(65, innerWidth / innerHeight, 0.1, 600);
    camera.position.set(-12, 6, 12);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = false;  // no shadows in wireframe world
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 1.5, 0);
    controls.maxDistance = 60;
    controls.minDistance = 2;
    controls.enabled = false; // start in chase mode

    // Camera mode controls
    function updateCamButtons() {
      document.querySelectorAll('#cam-controls button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === camMode);
      });
      const info = document.getElementById('cam-mode-info');
      if (info) info.textContent = 'CAM: ' + camMode.toUpperCase();
    }
    document.querySelectorAll('#cam-controls button').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        camMode = btn.dataset.mode;
        controls.enabled = (camMode === 'free');
        updateCamButtons();
      });
    });
    // Mouse interaction on canvas → switch to free mode
    renderer.domElement.addEventListener('mousedown', () => {
      if (camMode !== 'free') {
        camMode = 'free';
        controls.enabled = true;
        updateCamButtons();
      }
    }, true);
    renderer.domElement.addEventListener('wheel', () => {
      if (camMode !== 'free') {
        camMode = 'free';
        controls.enabled = true;
        updateCamButtons();
      }
    }, true);

    // ======== LIGHTING — minimal, just enough for wireframe glow ========
    scene.add(new THREE.AmbientLight(0x33ff00, 0.8));
    const sun = new THREE.DirectionalLight(0x33ff00, 0.5);
    sun.position.set(10, 15, 8);
    scene.add(sun);

    // ======== TRACK & ENVIRONMENT — TERMINAL WIREFRAME AESTHETIC ========
    const trackWidth = NUM_BULLS * LANE_WIDTH + 2;
    const TRACK_LEN = 600;

    // ---- INFINITE GRID FLOOR ----
    // Glowing green grid on pure black — the signature terminal look
    const gridHelper = new THREE.GridHelper(TRACK_LEN, TRACK_LEN / 2, 0x1f521f, 0x0a2a0a);
    gridHelper.position.x = FINISH_X / 2;
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.4;
    scene.add(gridHelper);

    // Brighter grid just for the track area
    const trackGrid = new THREE.GridHelper(TRACK_LEN, TRACK_LEN / 2, 0x33ff00, 0x1f521f);
    trackGrid.position.x = FINISH_X / 2;
    trackGrid.position.y = 0.005;
    // Clip to track width using a narrow plane
    trackGrid.material.transparent = true;
    trackGrid.material.opacity = 0.15;
    scene.add(trackGrid);

    // Lane dividers — glowing green lines using LineSegments
    const laneMat = new THREE.LineBasicMaterial({ color: 0x33ff00, transparent: true, opacity: 0.7 });
    for (let lane = 0; lane <= NUM_BULLS; lane++) {
      const z = (lane - NUM_BULLS / 2) * LANE_WIDTH;
      const pts = [new THREE.Vector3(-10, 0.02, z), new THREE.Vector3(FINISH_X + 50, 0.02, z)];
      const lineGeo = new THREE.BufferGeometry().setFromPoints(pts);
      scene.add(new THREE.Line(lineGeo, laneMat));
    }

    // ======== TRACK-SIDE MARKERS — wireframe poles ========
    const markerGreenMat = new THREE.MeshBasicMaterial({ color: 0x33ff00, wireframe: true });
    const markerAmberMat = new THREE.MeshBasicMaterial({ color: 0xffb000, wireframe: true });
    const markerPostGeo = new THREE.CylinderGeometry(0.08, 0.08, 2.0, 4);
    const markerTopGeo = new THREE.OctahedronGeometry(0.15, 0);
    for (let x = 0; x <= FINISH_X + 20; x += 10) {
      for (let side = -1; side <= 1; side += 2) {
        const mat = markerGreenMat;
        const post = new THREE.Mesh(markerPostGeo, mat);
        post.position.set(x, 1.0, side * (trackWidth / 2 + 1.5));
        scene.add(post);
        const top = new THREE.Mesh(markerTopGeo, mat);
        top.position.set(x, 2.1, side * (trackWidth / 2 + 1.5));
        scene.add(top);
      }
    }

    // Distance number signs every 50m — terminal green text on black
    for (let x = 50; x <= FINISH_X; x += 50) {
      for (let side = -1; side <= 1; side += 2) {
        const signCanvas = document.createElement('canvas');
        signCanvas.width = 64; signCanvas.height = 32;
        const sCtx = signCanvas.getContext('2d');
        sCtx.fillStyle = '#000000';
        sCtx.fillRect(0, 0, 64, 32);
        sCtx.strokeStyle = '#33ff00';
        sCtx.lineWidth = 1;
        sCtx.strokeRect(1, 1, 62, 30);
        sCtx.fillStyle = '#33ff00';
        sCtx.font = 'bold 20px monospace';
        sCtx.textAlign = 'center';
        sCtx.textBaseline = 'middle';
        sCtx.fillText(`${x}M`, 32, 16);
        const signTex = new THREE.CanvasTexture(signCanvas);
        const signPlane = new THREE.Mesh(
          new THREE.PlaneGeometry(0.8, 0.4),
          new THREE.MeshBasicMaterial({ map: signTex, transparent: true })
        );
        signPlane.position.set(x, 2.4, side * (trackWidth / 2 + 1.5));
        signPlane.rotation.y = side > 0 ? -Math.PI / 2 : Math.PI / 2;
        scene.add(signPlane);
      }
    }

    // Ground chevrons — glowing scan lines on track
    const chevronMat = new THREE.LineBasicMaterial({ color: 0x33ff00, transparent: true, opacity: 0.06 });
    for (let x = 0; x <= FINISH_X + 20; x += 5) {
      const pts = [
        new THREE.Vector3(x, 0.01, -trackWidth * 0.3),
        new THREE.Vector3(x, 0.01, trackWidth * 0.3)
      ];
      scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), chevronMat));
    }

    // Fence along track — wireframe boxes
    const FENCE_COUNT = 250;
    const fencePostGeo = new THREE.BoxGeometry(0.06, 1.0, 0.06);
    const fenceRailGeo = new THREE.BoxGeometry(2.5, 0.04, 0.04);
    const fenceMat = new THREE.MeshBasicMaterial({ color: 0x1f521f, wireframe: true });
    for (let side = -1; side <= 1; side += 2) {
      const z = side * (trackWidth / 2 + 2.5);
      const posts = new THREE.InstancedMesh(fencePostGeo, fenceMat, FENCE_COUNT);
      const rails1 = new THREE.InstancedMesh(fenceRailGeo, fenceMat, FENCE_COUNT - 1);
      const rails2 = new THREE.InstancedMesh(fenceRailGeo, fenceMat, FENCE_COUNT - 1);
      const m = new THREE.Matrix4();
      for (let i = 0; i < FENCE_COUNT; i++) {
        m.makeTranslation(-10 + i * 2.5, 0.5, z);
        posts.setMatrixAt(i, m);
        if (i < FENCE_COUNT - 1) {
          m.makeTranslation(-10 + i * 2.5 + 1.25, 0.75, z);
          rails1.setMatrixAt(i, m);
          m.makeTranslation(-10 + i * 2.5 + 1.25, 0.35, z);
          rails2.setMatrixAt(i, m);
        }
      }
      scene.add(posts, rails1, rails2);
    }

    // Trees — wireframe geometric shapes (terminal aesthetic)
    const treeWireMat = new THREE.MeshBasicMaterial({ color: 0x1f521f, wireframe: true });
    const treeGlowMat = new THREE.MeshBasicMaterial({ color: 0x33ff00, wireframe: true, transparent: true, opacity: 0.3 });
    for (let side = -1; side <= 1; side += 2) {
      for (let i = 0; i < 80; i++) {
        const g = new THREE.Group();
        // Trunk — wireframe cylinder
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.12, 1.5, 4), treeWireMat);
        trunk.position.y = 0.75;
        g.add(trunk);
        // Crown — wireframe icosahedron (looks cool and geometric)
        const crownGeo = Math.random() > 0.5
          ? new THREE.IcosahedronGeometry(0.7 + Math.random() * 0.5, 0)
          : new THREE.OctahedronGeometry(0.6 + Math.random() * 0.4, 0);
        const crown = new THREE.Mesh(crownGeo, Math.random() > 0.3 ? treeWireMat : treeGlowMat);
        crown.position.y = 1.8 + Math.random() * 0.5;
        crown.rotation.y = Math.random() * Math.PI;
        g.add(crown);
        g.position.set(
          -20 + i * 7 + Math.random() * 4,
          0,
          side * (trackWidth / 2 + 5 + Math.random() * 15)
        );
        const s = 0.6 + Math.random() * 1.0;
        g.scale.setScalar(s);
        scene.add(g);
      }
    }

    // Start line — glowing green wireframe gate
    const startGateMat = new THREE.MeshBasicMaterial({ color: 0x33ff00, wireframe: true });
    const sp1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 3.5, 0.15), startGateMat);
    sp1.position.set(0, 1.75, -trackWidth / 2 - 2);
    scene.add(sp1);
    const sp2 = sp1.clone();
    sp2.position.z = trackWidth / 2 + 2;
    scene.add(sp2);
    const startBar = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, trackWidth + 4.2), startGateMat);
    startBar.position.set(0, 3.5, 0);
    scene.add(startBar);
    // START text on ground
    const startLineMat = new THREE.LineBasicMaterial({ color: 0x33ff00 });
    for (let z = -trackWidth / 2; z <= trackWidth / 2; z += 0.5) {
      const pts = [new THREE.Vector3(-0.5, 0.02, z), new THREE.Vector3(0.5, 0.02, z)];
      scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), startLineMat));
    }

    // Finish line — glowing amber wireframe arch
    const finishGateMat = new THREE.MeshBasicMaterial({ color: 0xffb000, wireframe: true });
    const fp1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4.5, 0.2), finishGateMat);
    fp1.position.set(FINISH_X, 2.25, -trackWidth / 2 - 2);
    scene.add(fp1);
    const fp2 = fp1.clone();
    fp2.position.z = trackWidth / 2 + 2;
    scene.add(fp2);
    const finishBar = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.35, trackWidth + 4.2),
      finishGateMat
    );
    finishBar.position.set(FINISH_X, 4.5, 0);
    scene.add(finishBar);
    // FINISH text
    const finTextCanvas = document.createElement('canvas');
    finTextCanvas.width = 512; finTextCanvas.height = 64;
    const ftCtx = finTextCanvas.getContext('2d');
    ftCtx.fillStyle = '#000000';
    ftCtx.fillRect(0, 0, 512, 64);
    ftCtx.fillStyle = '#ffb000';
    ftCtx.font = 'bold 42px monospace';
    ftCtx.textAlign = 'center';
    ftCtx.textBaseline = 'middle';
    ftCtx.fillText('> F I N I S H _', 256, 32);
    const finTextTex = new THREE.CanvasTexture(finTextCanvas);
    for (let rot of [Math.PI / 2, -Math.PI / 2]) {
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(trackWidth + 4, 0.6),
        new THREE.MeshBasicMaterial({ map: finTextTex, transparent: true })
      );
      plane.position.set(FINISH_X, 4.8, 0);
      plane.rotation.y = rot;
      scene.add(plane);
    }
    // Finish cross-hatch on ground
    const finLineMat = new THREE.LineBasicMaterial({ color: 0xffb000, transparent: true, opacity: 0.5 });
    for (let z = -trackWidth / 2; z <= trackWidth / 2; z += 0.5) {
      const pts = [new THREE.Vector3(FINISH_X - 1, 0.02, z), new THREE.Vector3(FINISH_X + 1, 0.02, z)];
      scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), finLineMat));
    }

    // ======== DUST PARTICLES ========
    const dustCount = 300;
    const dustPos = new Float32Array(dustCount * 3);
    const dustVel = [];
    for (let i = 0; i < dustCount; i++) {
      dustPos[i * 3 + 1] = -10;
      dustVel.push({ x: 0, y: 0, z: 0, life: 0 });
    }
    const dustGeo = new THREE.BufferGeometry();
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    scene.add(new THREE.Points(dustGeo,
      new THREE.PointsMaterial({ color: 0x33ff00, size: 0.1, transparent: true, opacity: 0.4 })
    ));
    let dustIdx = 0;
    function emitDust(px, py, pz, speed) {
      const count = Math.max(1, Math.floor(speed * 0.8));
      for (let k = 0; k < count; k++) {
        const i = dustIdx++ % dustCount;
        dustPos[i * 3] = px + (Math.random() - 0.5) * 0.4;
        dustPos[i * 3 + 1] = py + 0.05;
        dustPos[i * 3 + 2] = pz + (Math.random() - 0.5) * 0.4;
        dustVel[i] = {
          x: -speed * 0.4 + Math.random() * 0.5,
          y: 0.4 + Math.random() * 0.6,
          z: (Math.random() - 0.5) * 1.0,
          life: 0.8 + Math.random() * 0.5
        };
      }
    }

    // ======== SPEED LINE PARTICLES (green data streams streaking past) ========
    const speedLineCount = 120;
    const slPositions = new Float32Array(speedLineCount * 3);
    const slVelocities = [];
    for (let i = 0; i < speedLineCount; i++) {
      slPositions[i * 3] = Math.random() * 40 - 20;
      slPositions[i * 3 + 1] = 0.3 + Math.random() * 4;
      slPositions[i * 3 + 2] = (Math.random() - 0.5) * 30;
      slVelocities.push(-8 - Math.random() * 5);
    }
    const slGeo = new THREE.BufferGeometry();
    slGeo.setAttribute('position', new THREE.BufferAttribute(slPositions, 3));
    const speedLines = new THREE.Points(slGeo,
      new THREE.PointsMaterial({ color: 0x33ff00, size: 0.04, transparent: true, opacity: 0.35, sizeAttenuation: true })
    );
    scene.add(speedLines);

    // ======== LOAD FBX & SETUP BULLS (Skeletal Animation) ========
    const clock = new THREE.Clock();
    const bulls = [];
    let raceStarted = false;
    let raceStartTime = 0;
    let countdownStarted = false;

    // Strip root_bone position tracks from a clip (we control movement ourselves)
    function stripRootMotion(clip) {
      clip.tracks = clip.tracks.filter(track => {
        return !(track.name.includes('root_bone') && track.name.endsWith('.position'));
      });
      return clip;
    }

    const loader = new FBXLoader();
    loader.load('bull-animations-v02/source/Bull.fbx', (fbx) => {
      const loadEl = document.getElementById('loading');
      loadEl.textContent = 'LFG!!!!';
      loadEl.classList.add('lfg');
      setTimeout(() => { loadEl.style.display = 'none'; }, 1500);

      // Log available animations
      console.log(`Animations found: ${fbx.animations.length}`);
      fbx.animations.forEach((c, i) => console.log(`  [${i}] ${c.name} (${c.duration.toFixed(2)}s)`));

      // Find key animation clips
      const runClip = stripRootMotion(
        fbx.animations.find(c => c.name.includes('Run_F_RM')) || fbx.animations[0]
      );
      const idleClip = stripRootMotion(
        fbx.animations.find(c => c.name.includes('Idle_1')) || fbx.animations[0]
      );
      const trotClip = stripRootMotion(
        fbx.animations.find(c => c.name.includes('Trot_F_RM')) || runClip
      );
      const walkClip = stripRootMotion(
        fbx.animations.find(c => c.name.includes('Walk_F_RM')) ||
        fbx.animations.find(c => c.name.includes('Walk')) || trotClip
      );
      const lieStartClip = stripRootMotion(
        fbx.animations.find(c => c.name.includes('Lie_start')) || idleClip
      );
      const lieLoopClip = stripRootMotion(
        fbx.animations.find(c => c.name.includes('Lie_loop1')) ||
        fbx.animations.find(c => c.name.includes('Lie_loop')) || idleClip
      );
      const attackRunClip = stripRootMotion(
        fbx.animations.find(c => c.name.includes('Attack_Run_RM')) || runClip
      );
      // Collect all idle variants for random assignment
      const idleClips = fbx.animations
        .filter(c => /Idle_\d/.test(c.name))
        .map(c => stripRootMotion(c));
      if (idleClips.length === 0) idleClips.push(idleClip);
      console.log(`Using run: "${runClip.name}", walk: "${walkClip.name}", attack: "${attackRunClip.name}", idles: ${idleClips.length}, lie: "${lieStartClip.name}"`);

      // Scale model: body is along Z (size z=3.42), height y=1.56
      const box0 = new THREE.Box3().setFromObject(fbx);
      const size0 = box0.getSize(new THREE.Vector3());
      const targetHeight = 2.5;  // desired bull height in world units
      const scale = targetHeight / size0.y;

      // Apply wireframe material to source mesh
      fbx.traverse(child => {
        if (child.isMesh) {
          child.material = new THREE.MeshBasicMaterial({
            color: 0x33ff00,
            wireframe: true,
            transparent: true,
            opacity: 0.85,
          });
        }
      });

      // Auto-detect rotation: model body is along Z (z=3.42 > x=0.79)
      // We need body along +X for our track. The head should face +X.
      // Test rotations to find correct one
      let bestRotY = -Math.PI / 2;  // default: rotate -90° to go from Z to X
      {
        const testClone = SkeletonUtils.clone(fbx);
        testClone.scale.setScalar(scale);
        let bestScore = -Infinity;
        for (const tryRot of [0, Math.PI / 2, Math.PI, -Math.PI / 2]) {
          testClone.rotation.y = tryRot;
          testClone.updateMatrixWorld(true);
          const tb = new THREE.Box3().setFromObject(testClone);
          const tc = tb.getCenter(new THREE.Vector3());
          const ts = tb.getSize(new THREE.Vector3());
          if (ts.x < ts.z * 0.8) continue;
          // Find where the head (highest Y) is — should be at +X
          let plusXMaxY = -Infinity, minusXMaxY = -Infinity;
          testClone.traverse(child => {
            if (child.isMesh) {
              const pos = child.geometry.attributes.position;
              const wp = new THREE.Vector3();
              child.updateMatrixWorld(true);
              for (let vi = 0; vi < pos.count; vi += 10) {
                wp.set(pos.getX(vi), pos.getY(vi), pos.getZ(vi));
                child.localToWorld(wp);
                if (wp.x > tc.x) plusXMaxY = Math.max(plusXMaxY, wp.y);
                else minusXMaxY = Math.max(minusXMaxY, wp.y);
              }
            }
          });
          const score = (plusXMaxY - minusXMaxY) + (ts.x - ts.z) * 0.1;
          if (score > bestScore) { bestScore = score; bestRotY = tryRot; }
        }
        console.log(`Auto-detected rotation: ${(bestRotY * 180 / Math.PI).toFixed(0)}°`);
      }

      // Create 8 bulls using SkeletonUtils.clone
      for (let i = 0; i < NUM_BULLS; i++) {
        const laneZ = (i - NUM_BULLS / 2 + 0.5) * LANE_WIDTH;
        const laneGroup = new THREE.Group();
        laneGroup.position.z = laneZ;

        // Clone the entire FBX (preserves skeleton + skinning)
        const bullClone = SkeletonUtils.clone(fbx);
        bullClone.scale.setScalar(scale);
        bullClone.rotation.y = bestRotY;

        // Apply unique wireframe color
        bullClone.traverse(child => {
          if (child.isMesh) {
            child.material = new THREE.MeshBasicMaterial({
              color: bullColors[i].wire,
              wireframe: true,
              transparent: true,
              opacity: 0.85,
            });
          }
        });

        laneGroup.add(bullClone);
        laneGroup.updateMatrixWorld(true);

        // Center on ground
        const bullBox = new THREE.Box3().setFromObject(laneGroup);
        const bullCenter = bullBox.getCenter(new THREE.Vector3());
        bullClone.position.y -= bullBox.min.y;
        bullClone.position.x -= bullCenter.x;
        bullClone.position.z -= (bullCenter.z - laneZ);

        scene.add(laneGroup);

        // Setup AnimationMixer
        const mixer = new THREE.AnimationMixer(bullClone);
        const idleAction = mixer.clipAction(idleClip);
        const runAction = mixer.clipAction(runClip);
        const walkAction = mixer.clipAction(walkClip);
        const lieStartAction = mixer.clipAction(lieStartClip);
        const lieLoopAction = mixer.clipAction(lieLoopClip);
        const attackRunAction = mixer.clipAction(attackRunClip);
        attackRunAction.setLoop(THREE.LoopOnce);
        attackRunAction.clampWhenFinished = true;

        // Pick a random idle variant for this bull's post-finish rest
        const restIdleClip = idleClips[Math.floor(Math.random() * idleClips.length)];
        const restIdleAction = mixer.clipAction(restIdleClip);

        // Lie-down plays once then holds final pose
        lieStartAction.setLoop(THREE.LoopOnce);
        lieStartAction.clampWhenFinished = true;

        // Start with walk toward the start line
        walkAction.play();

        // Offset animation time so bulls aren't all in sync
        const timeOffset = Math.random() * walkClip.duration;
        mixer.setTime(timeOffset);

        // Auto-transition on animation finish events
        mixer.addEventListener('finished', (e) => {
          if (e.action === lieStartAction) {
            lieStartAction.fadeOut(0.5);
            lieLoopAction.reset().fadeIn(0.5).play();
          }
          // Winner: attack ends → walk
          if (e.action === attackRunAction) {
            attackRunAction.fadeOut(0.5);
            walkAction.reset().fadeIn(0.5).play();
            // Mark as walking so the winner block stops matching
            const b = bulls.find(b => b.mixer === mixer);
            if (b) b.isWalking = true;
          }
        });

        // Per-bull random post-finish timing
        const walkDuration = 3 + Math.random() * 4;     // 3-7s of walking
        const idleDuration = 3 + Math.random() * 3;     // 3-6s of idle before lying

        // Trail geometry — fading color trace behind each bull
        const TRAIL_LEN = 120;
        const trailPositions = new Float32Array(TRAIL_LEN * 3);
        const trailColors = new Float32Array(TRAIL_LEN * 3);
        const tc = new THREE.Color(bullColors[i].wire);
        for (let j = 0; j < TRAIL_LEN; j++) {
          trailPositions[j * 3 + 1] = -10; // hide below ground initially
          const t = 1 - j / TRAIL_LEN;
          trailColors[j * 3] = tc.r * t;
          trailColors[j * 3 + 1] = tc.g * t;
          trailColors[j * 3 + 2] = tc.b * t;
        }
        const trailGeo = new THREE.BufferGeometry();
        trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
        trailGeo.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
        const trail = new THREE.Line(trailGeo, new THREE.LineBasicMaterial({
          vertexColors: true, transparent: true, opacity: 0.6
        }));
        scene.add(trail);

        bulls.push({
          group: laneGroup,
          clone: bullClone,
          mixer,
          trail, trailGeo, trailPositions, trailLen: TRAIL_LEN,
          idleAction,
          runAction,
          walkAction,
          lieStartAction,
          lieLoopAction,
          attackRunAction,
          restIdleAction,
          speed: 10 + Math.random() * 5,
          phase: Math.random() * Math.PI * 2,
          laneZ,
          racePos: -20 - Math.random() * 10,
          startTarget: -3,
          walkSpeed: 2.0 + Math.random() * 0.8,
          arrived: false,
          name: bullColors[i].name,
          color: bullColors[i].dot,
          finished: false,
          finishRank: 0,
          finishTime: 0,
          isRunning: false,
          isWalking: false,
          isIdling: false,
          isLying: false,
          // Per-bull post-finish phase durations
          postDecel: 2,
          postWalkEnd: 2 + walkDuration,
          postIdleEnd: 2 + walkDuration + idleDuration,
        });
      }

      console.log(`${NUM_BULLS} bulls loaded — speeds: ${bulls.map(b => b.speed.toFixed(1)).join(', ')}`);
      // Countdown starts when all bulls walk to the start line

    }, (progress) => {
      if (progress.total > 0) {
        const pct = Math.min(100, Math.round(progress.loaded / progress.total * 100));
        document.getElementById('loading').textContent = `> initializing_bull_run [${pct}%]`;
      }
    }, (error) => {
      console.error('Error:', error);
      document.getElementById('loading').textContent = `> ERROR: ${error.message}_`;
    });

    // ======== AUDIO (Web Audio API — procedural, no files) ========
    let audioCtx = null;
    function ensureAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      return audioCtx;
    }

    // Countdown beep: short tone
    function playBeep(freq, duration, volume = 0.3) {
      const ctx = ensureAudio();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'square';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + duration);
    }

    // Placeholder for future running sound (file-based)
    function startHoofbeats() {}
    function stopHoofbeats() {}

    // ======== COUNTDOWN ========
    function startCountdown() {
      const cdEl = document.getElementById('countdown');
      cdEl.style.display = 'block';
      let count = 3;
      cdEl.textContent = `> ${count}_`;
      playBeep(440, 0.15, 0.25);
      const interval = setInterval(() => {
        count--;
        if (count > 0) {
          cdEl.textContent = `> ${count}_`;
          playBeep(440, 0.15, 0.25);
        } else if (count === 0) {
          cdEl.textContent = '> RUN_';
          cdEl.className = 'go';
          playBeep(880, 0.4, 0.35);
          raceStarted = true;
          raceStartTime = clock.getElapsedTime();
          startHoofbeats();
        } else {
          cdEl.style.display = 'none';
          cdEl.className = '';
          clearInterval(interval);
        }
      }, 1000);
    }

    // ======== LEADERBOARD ========
    let nextRank = 1;
    let raceOver = false;

    function updateLeaderboard() {
      const sorted = [...bulls].sort((a, b) => {
        if (a.finished && b.finished) return a.finishRank - b.finishRank;
        if (a.finished) return -1;
        if (b.finished) return 1;
        return b.racePos - a.racePos;
      });
      const lb = document.getElementById('lb-body');
      lb.innerHTML = sorted.map((b, i) => {
        const medal = i === 0 ? ' <span class="medal">[1ST]</span>' : i === 1 ? ' <span class="medal">[2ND]</span>' : i === 2 ? ' <span class="medal">[3RD]</span>' : '';
        const fin = b.finished ? ' <span class="done">[OK]</span>' : '';
        const pct = Math.min(100, Math.max(0, (b.racePos / FINISH_X) * 100)).toFixed(0);
        return `<div class="lane"><span class="pos">${String(i+1).padStart(2,'0')}.</span><span class="dot" style="background:${b.color}"></span><span class="name-text">${b.name}</span>${medal}${fin} ${pct}%</div>`;
      }).join('');

      // Update stats bar
      if (raceStarted) {
        const lead = sorted[0];
        const elapsed = clock.getElapsedTime() - raceStartTime;
        document.getElementById('clock-display').textContent = formatTime(elapsed);
        document.getElementById('speed-info').textContent = `SPD: ${lead.speed.toFixed(1)} M/S | ${lead.name}`;
        document.getElementById('track-info').textContent = `> POS: ${lead.racePos.toFixed(0)}M / ${FINISH_X}M`;
      }
    }

    function formatTime(s) {
      const m = Math.floor(s / 60);
      const sec = s % 60;
      return `${String(m).padStart(2,'0')}:${sec.toFixed(1).padStart(4,'0')}`;
    }

    // ======== ANIMATION ========
    let camTrackX = 0;       // smoothed X that the camera tracks
    let lastCamTrackX = 0;   // previous frame's value for computing delta
    let cameraReady = false;
    let camMode = 'chase';   // 'free' | 'top' | 'front' | 'chase'
    const _camPos = new THREE.Vector3();
    const _camTgt = new THREE.Vector3();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);
      const elapsed = clock.getElapsedTime();

      if (bulls.length > 0 && raceStarted) {
        const raceTime = elapsed - raceStartTime;

        // Move each bull forward
        for (const bull of bulls) {
          if (bull.finished) {
            const t = elapsed - bull.finishTime;

            // ---- WINNER: Attack_Run celebration ----
            if (bull.finishRank === 1 && !bull.isWalking) {
              const moveSpeed = bull.speed * 0.5;
              bull.racePos += moveSpeed * dt;
              if (!bull.attackStarted) {
                bull.attackStarted = true;
                bull.runAction.fadeOut(0.4);
                bull.attackRunAction.reset().fadeIn(0.4).play();
                bull.attackRunAction.timeScale = 1.0;
              }
            }
            // ---- Phase 1: Decelerate, run/attack → walk ----
            else if (t < bull.postDecel) {
              const moveSpeed = 2.0 + (bull.speed * 0.3) * (1 - t / bull.postDecel);
              bull.racePos += moveSpeed * dt;
              if (!bull.isWalking) {
                bull.isWalking = true;
                bull.runAction.fadeOut(0.8);
                bull.walkAction.reset().fadeIn(0.8).play();
              }
              bull.walkAction.timeScale = moveSpeed / 1.5;
            }
            // ---- Phase 2: Walk (varied duration per bull) ----
            else if (t < bull.postWalkEnd) {
              bull.isWalking = true;
              const progress = (t - bull.postDecel) / (bull.postWalkEnd - bull.postDecel);
              const moveSpeed = 1.8 * Math.max(0.1, 1 - progress * 0.8);
              bull.racePos += moveSpeed * dt;
              bull.walkAction.timeScale = moveSpeed / 1.5;
            }
            // ---- Phase 3: Random idle animation ----
            else if (t < bull.postIdleEnd) {
              if (!bull.isIdling) {
                bull.isIdling = true;
                bull.walkAction.fadeOut(0.8);
                bull.restIdleAction.reset().fadeIn(0.8).play();
              }
            }
            // ---- Phase 4: Lie down ----
            else if (!bull.isLying) {
              bull.isLying = true;
              bull.restIdleAction.fadeOut(1.0);
              bull.lieStartAction.reset().fadeIn(1.0).play();
            }

            bull.group.position.x = bull.racePos;
            bull.mixer.update(dt);
            continue;
          }

          // Transition idle → run on first racing frame
          if (!bull.isRunning) {
            bull.isRunning = true;
            bull.runAction.timeScale = 0.8 + (bull.speed / 15) * 0.6;
            bull.idleAction.fadeOut(0.3);
            bull.runAction.reset().fadeIn(0.3).play();
          }

          const surge = Math.sin(raceTime * 1.5 + bull.phase) * 1.0
                      + Math.sin(raceTime * 0.5 + bull.phase * 2.3) * 0.6;
          const currentSpeed = Math.max(1.0, bull.speed + surge);
          bull.racePos += currentSpeed * dt;

          if (bull.racePos >= FINISH_X) {
            bull.finished = true;
            bull.finishTime = elapsed;
            bull.finishRank = nextRank++;
            if (bull.finishRank === 1) {
              // Capture winner photo from glamour angle
              let photoURL = '';
              try {
                const photoRenderer = new THREE.WebGLRenderer({ antialias: true });
                photoRenderer.setSize(400, 300);
                photoRenderer.setPixelRatio(1);
                const photoCam = new THREE.PerspectiveCamera(40, 400 / 300, 0.1, 200);
                const bx = bull.racePos;
                const bz = bull.laneZ;
                photoCam.position.set(bx + 4, 2.5, bz + 5);
                photoCam.lookAt(bx, 1.2, bz);
                photoRenderer.render(scene, photoCam);
                photoURL = photoRenderer.domElement.toDataURL('image/png');
                photoRenderer.dispose();
              } catch(e) { console.warn('Winner photo failed:', e); }

              const finTime = elapsed - raceStartTime;
              const avgSpeed = (FINISH_X / finTime).toFixed(1);
              const wd = document.getElementById('winner');
              const photoHtml = photoURL ? `<img id="winner-photo" src="${photoURL}" alt="${bull.name}">` : '';
              document.getElementById('winner-body').innerHTML =
                photoHtml +
                `<div class="stats">` +
                `> winner: <span class="name" style="color:${bull.color}">${bull.name}</span>\n` +
                `> time: ${formatTime(finTime)}\n` +
                `> avg_speed: ${avgSpeed} M/S\n` +
                `> rank: 1/${NUM_BULLS}</div>`;
              wd.style.display = 'block';
            }
            if (nextRank > NUM_BULLS) { raceOver = true; stopHoofbeats(); }
          }

          bull.group.position.x = bull.racePos;
          bull.mixer.update(dt);

          // Emit dust at hooves
          emitDust(bull.racePos - 1, 0, bull.laneZ, currentSpeed);
        }

        // ---- CAMERA & SCENE TRACKING ----
        const sorted = [...bulls].sort((a, b) => b.racePos - a.racePos);
        const leaderX = sorted[0].racePos;
        const middle = sorted[Math.floor(NUM_BULLS / 2)].racePos;
        const goalX = leaderX * 0.4 + middle * 0.6;
        camTrackX += (goalX - camTrackX) * 1.5 * dt;

        // Move light, grid, speed lines with pack (all modes)
        sun.position.x = camTrackX + 10;
        gridHelper.position.x = Math.round(camTrackX / 2) * 2;
        trackGrid.position.x = Math.round(camTrackX / 2) * 2;
        speedLines.position.x = camTrackX;

        // Camera mode positioning
        controls.enabled = (camMode === 'free');
        if (camMode === 'free') {
          const dx = camTrackX - lastCamTrackX;
          camera.position.x += dx;
          controls.target.x += dx;
        } else {
          const lerpF = 1 - Math.exp(-5 * dt);
          if (camMode === 'chase') {
            _camPos.set(leaderX - 15, 5, 8);
            _camTgt.set(leaderX + 5, 1.2, 0);
          } else if (camMode === 'top') {
            _camPos.set(leaderX, 50, 0.01);
            _camTgt.set(leaderX, 0, 0);
          } else if (camMode === 'side') {
            _camPos.set(leaderX, 3, 20);
            _camTgt.set(leaderX, 1.2, 0);
          } else if (camMode === 'front') {
            _camPos.set(leaderX + 15, 3, 0);
            _camTgt.set(leaderX, 1.2, 0);
          }
          camera.position.lerp(_camPos, lerpF);
          controls.target.lerp(_camTgt, lerpF);
          camera.lookAt(controls.target);
        }
        lastCamTrackX = camTrackX;

      } else if (bulls.length > 0) {
        // Pre-race: bulls walk up to the start line
        let allArrived = true;
        for (const bull of bulls) {
          if (!bull.arrived) {
            // Walk forward toward start position
            bull.racePos += bull.walkSpeed * dt;
            // Sync walk animation speed to movement speed
            bull.walkAction.timeScale = bull.walkSpeed / 1.5;
            if (bull.racePos >= bull.startTarget) {
              bull.racePos = bull.startTarget;
              bull.arrived = true;
              // Transition walk → idle at the line
              bull.walkAction.fadeOut(0.6);
              bull.idleAction.reset().fadeIn(0.6).play();
            } else {
              allArrived = false;
            }
          }
          bull.group.position.x = bull.racePos;
          bull.mixer.update(dt);
        }

        // Start countdown once every bull is at the line
        if (allArrived && !countdownStarted) {
          countdownStarted = true;
          startCountdown();
        }

        // Pre-race camera
        controls.enabled = (camMode === 'free');
        {
          const maxBullX = Math.max(...bulls.map(b => b.racePos));
          if (camMode === 'chase') {
            _camPos.set(maxBullX - 15, 5, 8);
            _camTgt.set(maxBullX + 5, 1.2, 0);
          } else if (camMode === 'top') {
            _camPos.set(maxBullX, 50, 0.01);
            _camTgt.set(maxBullX, 0, 0);
          } else if (camMode === 'side') {
            _camPos.set(maxBullX, 3, 20);
            _camTgt.set(maxBullX, 1.2, 0);
          } else if (camMode === 'front') {
            _camPos.set(maxBullX + 15, 3, 0);
            _camTgt.set(maxBullX, 1.2, 0);
          }
          if (camMode !== 'free') {
            if (!cameraReady) {
              camera.position.copy(_camPos);
              controls.target.copy(_camTgt);
              cameraReady = true;
            } else {
              const lerpF = 1 - Math.exp(-5 * dt);
              camera.position.lerp(_camPos, lerpF);
              controls.target.lerp(_camTgt, lerpF);
            }
            camera.lookAt(controls.target);
          } else if (!cameraReady) {
            camera.position.set(-12, 5, 8);
            controls.target.set(0, 1.2, 0);
            cameraReady = true;
          }
        }
      }

      // Dust update
      for (let i = 0; i < dustCount; i++) {
        const v = dustVel[i];
        if (v.life > 0) {
          dustPos[i*3] += v.x * dt;
          dustPos[i*3+1] += v.y * dt;
          dustPos[i*3+2] += v.z * dt;
          v.y -= dt * 0.4;
          v.life -= dt;
          if (v.life <= 0) dustPos[i*3+1] = -10;
        }
      }
      dustGeo.attributes.position.needsUpdate = true;

      // Update bull trails
      for (const bull of bulls) {
        const tp = bull.trailPositions;
        for (let j = bull.trailLen - 1; j > 0; j--) {
          tp[j * 3]     = tp[(j-1) * 3];
          tp[j * 3 + 1] = tp[(j-1) * 3 + 1];
          tp[j * 3 + 2] = tp[(j-1) * 3 + 2];
        }
        tp[0] = bull.racePos;
        tp[1] = 0.15;
        tp[2] = bull.laneZ;
        bull.trailGeo.attributes.position.needsUpdate = true;
      }

      // Update leaderboard
      if (bulls.length > 0 && Math.floor(elapsed * 4) !== Math.floor((elapsed - dt) * 4)) updateLeaderboard();

      if (camMode === 'free') controls.update();
      renderer.render(scene, camera);
    }
    animate();

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
