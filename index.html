<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MOONAD // moonad.fun</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&family=VT323&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0a;
      --primary: #33ff00;
      --secondary: #ffb000;
      --muted: #1f521f;
      --error: #ff3333;
      --border: #1f521f;
      --font: 'JetBrains Mono', 'Fira Code', monospace;
      --font-retro: 'VT323', monospace;
      --glow: 0 0 5px rgba(51, 255, 0, 0.5);
      --glow-strong: 0 0 10px rgba(51, 255, 0, 0.7), 0 0 20px rgba(51, 255, 0, 0.3);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: var(--bg); font-family: var(--font); }
    canvas { display: block; }

    /* CRT Scanline overlay */
    #crt-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 100;
      background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.08) 2px, rgba(0,0,0,0.08) 4px);
    }
    #crt-overlay::after {
      content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.4) 100%);
    }

    #hud {
      position: absolute; top: 0; left: 0; width: 100%; pointer-events: none;
      font-family: var(--font); z-index: 50;
    }

    /* Title bar */
    #title-bar {
      display: flex; justify-content: space-between; align-items: center;
      padding: 6px 12px;
      background: rgba(10, 10, 10, 0.85);
      border-bottom: 1px solid var(--muted);
      font-size: 11px; color: var(--primary);
      text-shadow: var(--glow);
    }
    #title-bar .sys { color: var(--muted); }
    #title-bar .title-text { letter-spacing: 2px; font-weight: 700; }
    #phase-indicator {
      padding: 2px 8px; font-weight: 700; font-size: 10px; letter-spacing: 1px;
      color: var(--bg);
    }
    #phase-indicator.betting { background: var(--primary); }
    #phase-indicator.switching { background: var(--secondary); }
    #phase-indicator.racing { background: var(--error); }
    #phase-indicator.closed { background: var(--muted); color: #ccc; }
    #phase-indicator.waiting { background: var(--muted); color: #ccc; }
    #clock-display { color: var(--primary); font-weight: 700; font-size: 12px; letter-spacing: 1px; text-shadow: var(--glow); }
    #pool-display { color: var(--secondary); font-weight: 700; }

    /* Leaderboard */
    #leaderboard {
      position: absolute; top: 35px; right: 10px;
      background: rgba(10, 10, 10, 0.9);
      border: 1px solid var(--muted);
      padding: 0; min-width: 240px;
      color: var(--primary); font-size: 11px; line-height: 1;
      text-shadow: var(--glow);
    }
    #lb-header {
      padding: 4px 8px;
      background: var(--primary); color: var(--bg);
      font-weight: 700; font-size: 10px; letter-spacing: 1px;
      text-shadow: none;
    }
    #lb-body { padding: 6px 8px; }
    #leaderboard .lane {
      display: flex; align-items: center; gap: 4px;
      padding: 2px 0; font-size: 11px;
      border-bottom: 1px solid rgba(31, 82, 31, 0.3);
    }
    #leaderboard .lane:last-child { border-bottom: none; }
    #leaderboard .dot { width: 6px; height: 6px; display: inline-block; flex-shrink: 0; }
    #leaderboard .pos { font-weight: 700; width: 20px; color: var(--muted); }
    #leaderboard .name-text { flex: 1; }
    #leaderboard .medal { color: var(--secondary); }
    #leaderboard .done { color: var(--primary); font-size: 9px; }

    /* Stats bar */
    #stats-bar {
      position: fixed; bottom: 0; left: 0; width: 100%;
      padding: 5px 12px;
      background: rgba(10, 10, 10, 0.85);
      border-top: 1px solid var(--muted);
      font-size: 10px; color: var(--muted);
      display: flex; justify-content: space-between;
      text-shadow: var(--glow);
      z-index: 50; pointer-events: none;
    }
    #stats-bar .active { color: var(--primary); }
    #stats-bar .warn { color: var(--secondary); }

    /* Phase display (center screen) */
    #phase-display {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: var(--primary); font-family: var(--font); font-size: 14px;
      text-shadow: var(--glow-strong);
      z-index: 55; text-align: center; pointer-events: none;
    }
    #phase-display::after {
      content: '_'; animation: blink 0.6s step-end infinite;
    }
    #phase-display.lfg {
      font-size: 15vw; font-weight: 800; letter-spacing: 0.05em;
    }
    #phase-display.lfg::after { content: ''; }
    #phase-display.hidden { display: none; }

    /* Start overlay — click to activate audio + begin */
    #start-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: var(--bg); z-index: 200; display: flex;
      flex-direction: column; align-items: center; justify-content: center;
      font-family: var(--font); color: var(--primary);
      text-shadow: var(--glow); cursor: pointer;
    }
    #start-overlay.hidden { display: none; }
    #start-overlay .boot-lines {
      font-size: 12px; color: var(--primary); text-align: left;
      margin-bottom: 24px; line-height: 1.8;
    }
    #start-overlay .boot-lines .ok { color: var(--primary); }
    #start-overlay .start-prompt {
      font-size: 16px; font-weight: 700; letter-spacing: 3px;
      animation: blink 1s step-end infinite;
    }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

    /* Countdown */
    #countdown {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: var(--primary); font-family: var(--font-retro); font-size: 120px;
      text-shadow: var(--glow-strong); z-index: 60;
    }
    #countdown.go { color: var(--secondary); text-shadow: 0 0 15px rgba(255,176,0,0.7); }

    /* Camera controls */
    #cam-controls {
      position: fixed; bottom: 28px; left: 10px;
      display: flex; gap: 4px; z-index: 50;
    }
    #cam-controls button {
      background: rgba(10, 10, 10, 0.9);
      border: 1px solid var(--muted); color: var(--muted);
      font-family: var(--font); font-size: 10px;
      padding: 3px 8px; cursor: pointer; letter-spacing: 1px;
      pointer-events: auto;
    }
    #cam-controls button:hover { border-color: var(--primary); color: var(--primary); }
    #cam-controls button.active {
      background: var(--primary); color: var(--bg);
      border-color: var(--primary); text-shadow: none;
    }

    /* ======== NEW: Wallet Button ======== */
    #wallet-btn {
      position: fixed; top: 6px; right: 12px;
      background: rgba(10, 10, 10, 0.9);
      border: 1px solid var(--primary); color: var(--primary);
      font-family: var(--font); font-size: 10px;
      padding: 4px 10px; cursor: pointer; letter-spacing: 1px;
      z-index: 55; pointer-events: auto;
      text-shadow: var(--glow);
    }
    #wallet-btn:hover { background: var(--primary); color: var(--bg); text-shadow: none; }
    #wallet-btn.connected { border-color: var(--muted); color: var(--muted); }

    #seed-btn {
      display: none; position: fixed; top: 6px; left: 12px;
      background: rgba(10, 10, 10, 0.9);
      border: 1px solid var(--secondary); color: var(--secondary);
      font-family: var(--font); font-size: 10px;
      padding: 4px 10px; cursor: pointer; letter-spacing: 1px;
      z-index: 55; pointer-events: auto;
      text-shadow: 0 0 5px rgba(255, 176, 0, 0.5);
      animation: pulse-border 1.5s ease-in-out infinite;
    }
    #seed-btn:hover { background: var(--secondary); color: var(--bg); text-shadow: none; }
    #seed-btn.hidden { display: none; }
    #seed-btn.visible { display: block; }

    /* ======== NEW: Bull Stat Cards (bottom panel) ======== */
    #bull-cards {
      position: fixed; bottom: 22px; left: 0; right: 0;
      display: none; gap: 3px; padding: 0 6px;
      z-index: 52; overflow-x: hidden; overflow-y: hidden;
      justify-content: center; flex-wrap: nowrap;
    }
    #bull-cards.visible { display: flex; animation: slideUp 0.4s ease-out; }
    .bull-card {
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid var(--muted);
      padding: 5px 6px; flex: 1 1 0; min-width: 0;
      font-size: 10px; color: var(--primary);
      cursor: pointer;
      pointer-events: auto; position: relative;
      transition: border-color 0.2s;
    }
    .bull-card:hover { border-color: var(--primary); }
    .bull-card.selected { border-color: var(--secondary); box-shadow: 0 0 8px rgba(255,176,0,0.3), 0 0 20px rgba(255,176,0,0.1); }
    .bull-card .card-name {
      font-weight: 700; font-size: 10px; letter-spacing: 0.5px;
      margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .bull-card .stat-row { display: flex; align-items: center; gap: 2px; margin: 1px 0; }
    .bull-card .stat-label { width: 52px; color: var(--muted); font-size: 8px; flex-shrink: 0; letter-spacing: 0.5px; }
    .bull-card .stat-bar-bg {
      flex: 1; height: 5px; background: rgba(31, 82, 31, 0.3); position: relative;
    }
    .bull-card .stat-bar-fill { height: 100%; transition: width 0.3s; }
    .bull-card .stat-val { width: 14px; text-align: right; font-size: 8px; }
    .bull-card .card-pool {
      margin-top: 4px; padding-top: 4px; border-top: 1px solid rgba(31,82,31,0.3);
      display: flex; justify-content: space-between; font-size: 9px; color: var(--muted);
    }
    .bull-card .card-odds { color: var(--secondary); }
    .bull-card .bet-btn {
      display: block; width: 100%; margin-top: 4px;
      background: none; border: 1px solid var(--primary); color: var(--primary);
      font-family: var(--font); font-size: 8px; padding: 3px 0;
      cursor: pointer; letter-spacing: 0.5px; text-align: center;
    }
    .bull-card .bet-btn:hover { background: var(--primary); color: var(--bg); }
    .bull-card .bet-btn.placed {
      border-color: var(--secondary); color: var(--secondary);
    }
    .bull-card .warning-badge {
      color: var(--error); font-size: 8px; margin-top: 3px;
      border: 1px solid var(--error); padding: 1px 3px; display: none;
    }

    /* ======== NEW: Bet Modal ======== */
    #bet-modal {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: var(--bg); border: 1px solid var(--primary);
      padding: 16px; z-index: 75; min-width: 280px;
      display: none; color: var(--primary); font-size: 12px;
    }
    #bet-modal .modal-title {
      font-weight: 700; font-size: 10px; letter-spacing: 1px;
      padding: 0 0 8px 0; border-bottom: 1px solid var(--muted);
      margin-bottom: 10px;
    }
    #bet-modal .modal-bull { color: var(--secondary); font-weight: 700; margin-bottom: 10px; }
    #bet-modal input {
      background: transparent; border: none; border-bottom: 1px solid var(--muted);
      color: var(--primary); font-family: var(--font);
      padding: 4px 0; font-size: 14px; flex: 1;
      outline: none;
    }
    #bet-modal input:focus { border-bottom-color: var(--primary); }
    #bet-modal .modal-info { color: var(--muted); font-size: 10px; margin: 8px 0; }
    #bet-modal .modal-btns { display: flex; gap: 8px; margin-top: 12px; }
    #bet-modal .modal-btns button {
      flex: 1; padding: 6px; border: 1px solid var(--muted);
      background: none; color: var(--muted); font-family: var(--font);
      font-size: 10px; cursor: pointer; letter-spacing: 1px;
    }
    #bet-modal .modal-btns .confirm-btn { border-color: var(--primary); color: var(--primary); }
    #bet-modal .modal-btns .confirm-btn:hover { background: var(--primary); color: var(--bg); }

    /* ======== NEW: Track Reveal Overlay ======== */
    #track-reveal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      display: none; z-index: 80;
      background: var(--bg);
      justify-content: center; align-items: center;
      flex-direction: column;
    }
    #track-reveal.visible { display: flex; }
    #track-reveal .track-name {
      font-family: var(--font); font-size: 7vw; font-weight: 800;
      color: var(--secondary); letter-spacing: 0.1em;
      text-shadow: 0 0 30px rgba(255,176,0,0.5), 0 0 60px rgba(255,176,0,0.2);
      transition: opacity 0.3s;
    }
    #track-reveal .track-sub {
      font-family: var(--font); font-size: 2vw; color: var(--muted);
      margin-top: 10px; letter-spacing: 2px;
    }

    /* ======== NEW: Results Panel ======== */
    #results-panel {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid var(--secondary);
      padding: 0; min-width: 340px; max-width: 400px;
      display: none; z-index: 65;
      color: var(--primary); font-size: 11px;
    }
    #results-panel.visible { display: block; animation: fadeIn 0.5s ease-out; }
    #results-header {
      padding: 4px 8px; background: var(--secondary); color: var(--bg);
      font-weight: 700; font-size: 10px; letter-spacing: 1px;
      display: flex; justify-content: space-between;
    }
    #results-body { padding: 12px; }
    #results-body .result-winner {
      font-size: 14px; font-weight: 800; color: var(--secondary);
      text-shadow: 0 0 8px rgba(255,176,0,0.4); margin-bottom: 10px;
    }
    #results-body .result-row {
      display: flex; justify-content: space-between; padding: 2px 0;
      border-bottom: 1px solid rgba(31,82,31,0.2); font-size: 10px;
    }
    #results-body .result-row.your-bet { color: var(--secondary); font-weight: 700; }
    #results-body .result-row .score { color: var(--muted); }
    #results-body .your-result {
      margin-top: 10px; padding-top: 8px;
      border-top: 1px solid var(--muted); font-size: 11px;
    }
    #results-body .your-result.won { color: var(--primary); }
    #results-body .your-result.lost { color: var(--error); }
    .claim-btn {
      display: block; width: 100%; margin-top: 10px;
      background: none; border: 1px solid var(--primary); color: var(--primary);
      font-family: var(--font); font-size: 11px; padding: 6px;
      cursor: pointer; letter-spacing: 1px; text-align: center;
      pointer-events: auto;
    }
    .claim-btn:hover { background: var(--primary); color: var(--bg); }
    #next-race-timer { color: var(--muted); font-size: 10px; margin-top: 8px; text-align: center; }

    /* ======== NEW: Your Bet Panel (right side) ======== */
    #your-bet-panel {
      position: fixed; top: 240px; right: 10px;
      background: rgba(10, 10, 10, 0.9); border: 1px solid var(--muted);
      padding: 0; min-width: 200px; display: none;
      color: var(--primary); font-size: 10px; z-index: 52;
    }
    #your-bet-panel.visible { display: block; }
    #your-bet-panel .yb-header {
      padding: 4px 8px; background: var(--secondary); color: var(--bg);
      font-weight: 700; font-size: 9px; letter-spacing: 1px;
    }
    #your-bet-panel .yb-body { padding: 8px; }
    #your-bet-panel .yb-warning {
      color: var(--error); font-size: 9px; margin-top: 6px;
      border: 1px solid var(--error); padding: 3px 6px;
    }
    .switch-btn {
      display: block; width: 100%; margin-top: 8px;
      background: none; border: 1px solid var(--secondary); color: var(--secondary);
      font-family: var(--font); font-size: 9px; padding: 4px;
      cursor: pointer; letter-spacing: 1px; text-align: center;
      pointer-events: auto;
    }
    .switch-btn:hover { background: var(--secondary); color: var(--bg); }

    /* Winner panel (reuse existing) */
    #winner {
      display: none; position: fixed; bottom: 40px; right: 10px;
      background: var(--bg); color: var(--secondary);
      font-family: var(--font); font-size: 16px;
      padding: 0; border: 1px solid var(--secondary);
      text-shadow: 0 0 8px rgba(255, 176, 0, 0.6);
      min-width: 280px; z-index: 60;
    }
    #winner-header {
      padding: 4px 8px; background: var(--secondary); color: var(--bg);
      font-weight: 700; font-size: 10px; letter-spacing: 1px;
      display: flex; justify-content: space-between; align-items: center;
    }
    #winner-close {
      cursor: pointer; pointer-events: auto;
      background: none; border: 1px solid var(--bg); color: var(--bg);
      font-family: var(--font); font-size: 12px; font-weight: 700;
      padding: 0 4px; line-height: 1.4;
    }
    #winner-close:hover { background: var(--bg); color: var(--secondary); }
    #winner-body { padding: 16px; }
    #winner .name { font-weight: 800; letter-spacing: 2px; }
    #winner .prompt { color: var(--muted); font-size: 11px; margin-top: 10px; }
    #winner-photo { border: 1px solid var(--secondary); width: 100%; display: block; margin-bottom: 8px; }
    #winner .stats { color: var(--secondary); font-size: 11px; line-height: 1.8; white-space: pre; }

    /* Phase badge in stats bar */
    .phase-badge {
      color: var(--bg); padding: 1px 6px; font-weight: 700;
      font-size: 9px; letter-spacing: 1px;
    }
    .phase-badge.betting { background: var(--primary); }
    .phase-badge.switching { background: var(--secondary); }
    .phase-badge.racing { background: var(--error); }

    /* ======== Claim Banner ======== */
    #claim-banner {
      display: none; position: fixed; top: 30px; left: 0; width: 100%;
      padding: 6px 12px; background: rgba(10, 10, 10, 0.95);
      border-top: 1px solid var(--primary); border-bottom: 1px solid var(--primary);
      color: var(--primary); font-size: 11px; text-align: center;
      z-index: 54; cursor: pointer; pointer-events: auto;
      letter-spacing: 1px; text-shadow: var(--glow);
      animation: pulse-border 1.5s ease-in-out infinite;
    }
    #claim-banner.visible { display: block; }
    @keyframes pulse-border {
      0%, 100% { border-color: var(--primary); text-shadow: var(--glow); }
      50% { border-color: var(--secondary); text-shadow: 0 0 8px rgba(255,176,0,0.5); }
    }

    /* ======== Modal Backdrop ======== */
    #bet-modal-backdrop {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.6); z-index: 74; display: none;
    }

    /* ======== Modal Countdown ======== */
    .modal-countdown {
      color: var(--secondary); font-size: 10px; margin-top: 8px;
      letter-spacing: 1px;
    }

    /* ======== Prompt-Style Input ======== */
    .input-prompt {
      display: flex; align-items: center; gap: 0;
      font-family: var(--font); font-size: 14px; color: var(--muted);
    }
    .input-prompt .prompt-prefix {
      color: var(--muted); font-size: 12px; white-space: nowrap;
      padding-right: 4px;
    }

    /* ======== ASCII Stat Bars ======== */
    .bull-card .stat-bar-ascii {
      flex: 1; font-size: 8px; letter-spacing: -0.5px; line-height: 1;
      font-family: var(--font); overflow: hidden;
    }

    /* ======== Panel Slide/Fade Animations ======== */
    @keyframes slideUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* ======== Track Reveal Glitch ======== */
    @keyframes screen-shake {
      0%, 100% { transform: translate(0, 0); }
      10% { transform: translate(-2px, 1px); }
      20% { transform: translate(2px, -1px); }
      30% { transform: translate(-1px, 2px); }
      40% { transform: translate(1px, -2px); }
      50% { transform: translate(-2px, -1px); }
      60% { transform: translate(2px, 1px); }
      70% { transform: translate(-1px, -2px); }
      80% { transform: translate(1px, 2px); }
      90% { transform: translate(-2px, 2px); }
    }
    #crt-overlay.glitch-intense {
      background: repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0,0,0,0.2) 1px, rgba(0,0,0,0.2) 2px);
      animation: screen-shake 0.15s linear infinite;
    }
    #track-reveal .track-sub {
      transition: opacity 0.3s;
    }

    /* ======== Temper Flicker ======== */
    @keyframes temper-flicker {
      0%, 100% { opacity: 0.85; }
      25% { opacity: 0.5; }
      50% { opacity: 0.9; }
      75% { opacity: 0.55; }
    }

    /* ======== Track Banner (dashboard) ======== */
    #track-banner {
      display: none; position: fixed; top: 35px; left: 10px;
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid var(--secondary);
      padding: 0; min-width: 220px;
      z-index: 52; color: var(--primary); font-size: 10px;
      text-shadow: var(--glow);
    }
    #track-banner.visible { display: block; animation: fadeIn 0.3s ease-out; }
    #track-banner .tb-header {
      padding: 4px 8px; background: var(--secondary); color: var(--bg);
      font-weight: 700; font-size: 9px; letter-spacing: 1px;
    }
    #track-banner .tb-body { padding: 6px 8px; }
    #track-banner .tb-name {
      font-weight: 700; font-size: 12px; color: var(--secondary);
      letter-spacing: 1px; margin-bottom: 3px;
    }
    #track-banner .tb-desc { color: var(--muted); font-size: 9px; margin-bottom: 5px; }
    #track-banner .tb-stat {
      display: flex; justify-content: space-between; font-size: 9px;
      padding: 1px 0; border-bottom: 1px solid rgba(31,82,31,0.2);
    }
    #track-banner .tb-stat:last-child { border-bottom: none; }
    #track-banner .tb-boost { color: var(--primary); }
    #track-banner .tb-penalty { color: var(--error); }
    #track-banner .tb-neutral { color: var(--muted); }

    /* ======== Bull Stat Popup (3D click) ======== */
    #bull-stat-popup {
      display: none; position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 10, 10, 0.97);
      border: 1px solid var(--primary);
      padding: 0; min-width: 320px; max-width: 380px; width: 90vw;
      z-index: 70; color: var(--primary); font-size: 12px;
      text-shadow: var(--glow);
      animation: fadeIn 0.2s ease-out;
    }
    #bull-stat-popup.visible { display: block; }
    #bull-stat-popup .popup-header {
      padding: 5px 10px; display: flex; justify-content: space-between; align-items: center;
      border-bottom: 1px solid var(--muted);
    }
    #bull-stat-popup .popup-header .popup-name {
      font-weight: 700; font-size: 13px; letter-spacing: 1px;
    }
    #bull-stat-popup .popup-close {
      background: none; border: 1px solid var(--muted); color: var(--muted);
      font-family: var(--font); font-size: 11px; cursor: pointer;
      padding: 1px 6px; pointer-events: auto;
    }
    #bull-stat-popup .popup-close:hover { border-color: var(--primary); color: var(--primary); }
    #bull-stat-popup .popup-body { padding: 10px 12px; }
    #bull-stat-popup .popup-stat {
      display: flex; align-items: center; gap: 6px; margin: 4px 0;
      font-size: 12px;
    }
    #bull-stat-popup .popup-stat-label { width: 75px; color: var(--primary); font-size: 11px; flex-shrink: 0; letter-spacing: 0.5px; }
    #bull-stat-popup .popup-stat-bar { flex: 1; font-size: 13px; letter-spacing: 1px; }
    #bull-stat-popup .popup-stat-val { width: 24px; text-align: right; font-weight: 700; font-size: 12px; }
    #bull-stat-popup .popup-pool {
      margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--muted);
      display: flex; justify-content: space-between; font-size: 11px;
    }
    #bull-stat-popup .popup-bet-btn {
      display: block; width: 100%; margin-top: 8px;
      background: none; border: 1px solid var(--primary); color: var(--primary);
      font-family: var(--font); font-size: 11px; padding: 6px;
      cursor: pointer; letter-spacing: 1px; text-align: center;
      pointer-events: auto;
    }
    #bull-stat-popup .popup-bet-btn:hover { background: var(--primary); color: var(--bg); }

    /* ======== Bet Trigger Button ======== */
    #bet-trigger-btn {
      display: none; position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid var(--primary); color: var(--primary);
      font-family: var(--font); font-size: 14px; font-weight: 700;
      padding: 10px 28px; cursor: pointer; letter-spacing: 2px;
      z-index: 55; pointer-events: auto;
      text-shadow: var(--glow-strong);
      box-shadow: 0 0 15px rgba(51, 255, 0, 0.3), inset 0 0 15px rgba(51, 255, 0, 0.05);
      animation: pulse-glow 2s ease-in-out infinite;
    }
    #bet-trigger-btn:hover {
      background: var(--primary); color: var(--bg);
      text-shadow: none;
      box-shadow: 0 0 25px rgba(51, 255, 0, 0.5);
    }
    #bet-trigger-btn.visible { display: block; }
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 15px rgba(51, 255, 0, 0.3), inset 0 0 15px rgba(51, 255, 0, 0.05); }
      50% { box-shadow: 0 0 25px rgba(51, 255, 0, 0.5), inset 0 0 25px rgba(51, 255, 0, 0.1); }
    }

    /* ======== Betting Panel Overlay ======== */
    #betting-panel-backdrop {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.7); z-index: 71; display: none;
    }
    #betting-panel-backdrop.visible { display: block; }
    #betting-panel {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: var(--bg);
      border: 1px solid var(--primary);
      max-width: 640px; width: 95vw;
      z-index: 72; display: none;
      color: var(--primary); font-size: 12px;
      text-shadow: var(--glow);
    }
    #betting-panel.visible { display: block; animation: fadeIn 0.3s ease-out; }
    #betting-panel-header {
      padding: 8px 12px;
      background: var(--primary); color: var(--bg);
      font-weight: 700; font-size: 13px; letter-spacing: 1px;
      display: flex; justify-content: space-between; align-items: center;
      text-shadow: none; gap: 8px;
    }
    #betting-panel-header .panel-title { flex: 1; text-align: left; white-space: nowrap; }
    #betting-panel-header .panel-counter { font-size: 12px; opacity: 0.8; }
    #betting-panel-header .panel-close {
      background: none; border: 1px solid var(--bg); color: var(--bg);
      font-family: var(--font); font-size: 12px; font-weight: 700;
      cursor: pointer; padding: 0 5px; line-height: 1.4;
      pointer-events: auto; flex-shrink: 0;
    }
    #betting-panel-header .panel-close:hover { background: var(--bg); color: var(--primary); }
    #betting-panel-body { padding: 20px; position: relative; }

    /* Side navigation arrows */
    .panel-nav-side {
      position: absolute; top: 50%; transform: translateY(-50%);
      background: rgba(10, 10, 10, 0.9);
      border: 1px solid var(--primary); color: var(--primary);
      font-family: var(--font); font-size: 18px; font-weight: 700;
      cursor: pointer; padding: 8px 6px; line-height: 1;
      pointer-events: auto; z-index: 73;
      text-shadow: var(--glow);
    }
    .panel-nav-side:hover { background: var(--primary); color: var(--bg); text-shadow: none; }
    .panel-nav-side.nav-left { left: -42px; }
    .panel-nav-side.nav-right { right: -42px; }

    /* Carousel content row: preview left, stats right */
    .carousel-content-row {
      display: flex; gap: 16px; margin-bottom: 14px; align-items: flex-start;
    }

    /* Bull preview canvas */
    .carousel-bull-preview {
      flex-shrink: 0; position: relative;
    }
    .carousel-bull-preview canvas {
      border: 1px solid var(--muted);
      background: var(--bg);
      display: block;
    }

    /* Carousel bull header */
    .carousel-bull-header {
      display: flex; align-items: center; gap: 12px; margin-bottom: 12px;
    }
    .carousel-bull-header .color-block {
      width: 28px; height: 28px; flex-shrink: 0;
    }
    .carousel-bull-header .bull-name {
      font-weight: 800; font-size: 18px; letter-spacing: 1px;
    }

    /* Carousel stat lines */
    .carousel-stats { flex: 1; min-width: 0; }
    .carousel-stat-line {
      display: flex; align-items: center; gap: 8px; margin: 5px 0; font-size: 13px;
      white-space: nowrap;
    }
    .carousel-stat-line .stat-label {
      width: 75px; color: var(--primary); font-size: 12px; letter-spacing: 0.5px;
      flex-shrink: 0; text-transform: uppercase;
    }
    .carousel-stat-line .stat-bar {
      flex: 1; font-size: 15px; letter-spacing: 1.5px;
    }
    .carousel-stat-line .stat-val {
      width: 28px; text-align: right; font-weight: 700; font-size: 13px;
    }

    /* Carousel pool area */
    .carousel-pool-area {
      display: flex; justify-content: space-between; align-items: center;
      padding: 12px 0; border-top: 1px solid var(--muted);
      font-size: 14px; margin-bottom: 12px;
    }
    .carousel-pool-area .pool-label { color: var(--primary); }
    .carousel-pool-area .pool-odds { color: var(--secondary); font-weight: 700; font-size: 16px; }

    /* Carousel bet button */
    .carousel-bet-btn {
      display: block; width: 100%;
      background: none; border: 1px solid var(--primary); color: var(--primary);
      font-family: var(--font); font-size: 14px; font-weight: 700;
      padding: 12px; cursor: pointer; letter-spacing: 2px;
      text-align: center; pointer-events: auto;
    }
    .carousel-bet-btn:hover { background: var(--primary); color: var(--bg); text-shadow: none; }
    .carousel-bet-btn.placed {
      border-color: var(--secondary); color: var(--secondary);
    }
    .carousel-bet-btn.placed:hover { background: var(--secondary); color: var(--bg); }

    /* Bull indicator dots */
    #bull-indicators {
      display: flex; justify-content: center; gap: 8px;
      padding: 10px; border-top: 1px solid var(--muted);
    }
    .bull-indicator {
      width: 8px; height: 8px; cursor: pointer;
      opacity: 0.4; transition: opacity 0.2s, transform 0.2s;
      pointer-events: auto;
    }
    .bull-indicator:hover { opacity: 0.7; }
    .bull-indicator.active {
      opacity: 1; transform: scale(1.5);
    }

    /* ======== Minor Polish ======== */
    .bull-card .stat-label, .bull-card .stat-val, .bull-card .card-pool,
    #lb-header, #results-header span, .yb-header, .modal-title {
      letter-spacing: 1px; text-transform: uppercase;
    }
  </style>
</head>
<body>
  <div id="crt-overlay"></div>

  <div id="hud">
    <div id="title-bar">
      <span class="sys">[SYS]</span>
      <span class="title-text">&gt; MOONAD // BULL RACE</span>
      <span id="phase-indicator"></span>
      <span id="pool-display">POOL: 0.00 MON</span>
      <span id="clock-display">00:00</span>
    </div>
    <div id="leaderboard">
      <div id="lb-header">+-- LEADERBOARD --+</div>
      <div id="lb-body"></div>
    </div>
  </div>

  <div id="claim-banner" onclick="claimWinnings()"></div>
  <div id="seed-btn" onclick="seedRace()">[ SEED RACE ]</div>
  <div id="wallet-btn" onclick="connectWallet()">[ CONNECT WALLET ]</div>

  <div id="track-banner">
    <div class="tb-header">+-- TRACK --+</div>
    <div class="tb-body" id="track-banner-body"></div>
  </div>

  <div id="your-bet-panel">
    <div class="yb-header">+-- YOUR BET --+</div>
    <div class="yb-body" id="your-bet-body"></div>
  </div>

  <div id="bull-cards"></div>

  <div id="bet-trigger-btn" onclick="openBettingPanel()">[ PLACE YOUR BETS ]</div>

  <div id="betting-panel-backdrop" onclick="closeBettingPanel()"></div>
  <div id="betting-panel">
    <div id="betting-panel-header">
      <span class="panel-title">+-- BETTING SHEET --+</span>
      <span class="panel-counter" id="betting-panel-counter">1/8</span>
      <span id="betting-panel-timer"></span>
      <button class="panel-close" onclick="closeBettingPanel()">[X]</button>
    </div>
    <button class="panel-nav-side nav-left" onclick="prevBull()">&lt;</button>
    <button class="panel-nav-side nav-right" onclick="nextBull()">&gt;</button>
    <div id="betting-panel-body"></div>
    <div id="bull-indicators"></div>
  </div>

  <div id="bet-modal-backdrop" onclick="closeBetModal()"></div>
  <div id="bet-modal">
    <div class="modal-title">+-- PLACE BET --+</div>
    <div class="modal-bull" id="modal-bull-name"></div>
    <div class="input-prompt">
      <span class="prompt-prefix">> bet_amount: </span>
      <input type="number" id="bet-amount" placeholder="0.00" min="0.01" max="100" step="0.01">
      <span style="color:var(--muted);font-size:12px;margin-left:4px">MON</span>
    </div>
    <div class="modal-info">Min: 0.01 MON | Max: 100 MON</div>
    <div class="modal-info" id="modal-odds"></div>
    <div class="modal-countdown" id="modal-countdown"></div>
    <div class="modal-btns">
      <button onclick="closeBetModal()">[ CANCEL ]</button>
      <button class="confirm-btn" onclick="confirmBet()">[ CONFIRM BET ]</button>
    </div>
  </div>

  <div id="track-reveal">
    <div class="track-name" id="track-reveal-name"></div>
    <div class="track-sub" id="track-reveal-sub"></div>
  </div>

  <div id="results-panel">
    <div id="results-header"><span>+-- RACE COMPLETE --+</span></div>
    <div id="results-body"></div>
  </div>

  <div id="stats-bar">
    <span class="active" id="track-info">&gt; TRACK: --- | 8 BULLS</span>
    <span id="phase-info"></span>
    <span id="speed-info" class="warn">SPD: --.- M/S</span>
    <span id="bal-display" class="active">BAL: --.-- MON</span>
    <span class="sys" id="cam-mode-info">CAM: CHASE</span>
  </div>

  <div id="cam-controls">
    <button data-mode="free">FREE</button>
    <button data-mode="top">TOP</button>
    <button data-mode="side">SIDE</button>
    <button data-mode="front">FRONT</button>
    <button data-mode="chase" class="active">CHASE</button>
  </div>

  <div id="bull-stat-popup">
    <div class="popup-header">
      <span class="popup-name" id="popup-bull-name"></span>
      <button class="popup-close" onclick="hideBullStatPopup()">[X]</button>
    </div>
    <div class="popup-body" id="popup-body"></div>
  </div>

  <div id="start-overlay" class="hidden">
    <div class="boot-lines" id="boot-lines"></div>
    <div class="start-prompt">[ CLICK TO START ]</div>
  </div>
  <div id="phase-display">&gt; loading_model</div>
  <div id="winner">
    <div id="winner-header"><span>+-- RACE COMPLETE --+</span><button id="winner-close" onclick="document.getElementById('winner').style.display='none'">[X]</button></div>
    <div id="winner-body"></div>
  </div>
  <div id="countdown"></div>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
      "@reown/appkit-cdn": "https://cdn.jsdelivr.net/npm/@reown/appkit-cdn@1.8.18/dist/appkit.js"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
    import { createAppKit, WagmiAdapter } from '@reown/appkit-cdn';

    // ======== CONFIGURATION ========

    // ======== LIVE MODE SYNC (UTC-based timing from contract) ========
    let liveEpoch = 1770854400;
    let liveCycleDuration = 900;
    let liveBettingDuration = 480;
    let liveSwitchingEnd = 660;
    let liveConfigLoaded = false;
    let livePollInterval = null;
    let liveRaceDataLoaded = false;

    const NUM_BULLS = 8;
    const LANE_WIDTH = 2.4;
    const FINISH_X = 500;

    const TRACK_TYPES = [
      { name: 'FLAT SPRINT', dist: 200, desc: 'Short explosive dash' },
      { name: 'ENDURANCE', dist: 800, desc: 'The long haul' },
      { name: 'MUD PIT', dist: 500, desc: 'Heavy slog through mud' },
      { name: 'ROCKY CANYON', dist: 400, desc: 'Jagged uneven terrain' },
      { name: 'STEEP INCLINE', dist: 300, desc: 'Uphill grind' },
      { name: 'DOWNHILL RUSH', dist: 300, desc: 'Gravity-assisted chaos' },
      { name: 'ZIGZAG', dist: 400, desc: 'Hairpin turns every 50m' },
      { name: 'THUNDERSTORM', dist: 500, desc: 'Rain, lightning, chaos' },
      { name: 'SAND DUNES', dist: 500, desc: 'Soft shifting ground' },
      { name: 'NIGHT TRAIL', dist: 600, desc: 'Low visibility darkness' },
    ];

    // Track multipliers: [Speed, Stamina, Accel, Strength, Agility, Temper]
    const TRACK_MULTIPLIERS = [
      [ 10,  1,  9,  1,  2,  4],   // Flat Sprint
      [  5, 10,  0,  3,  1, -3],   // Endurance
      [ -4,  6, -2, 10,  3, -3],   // Mud Pit
      [ -2,  2,  3,  1, 10, -5],   // Rocky Canyon
      [ -2,  8,  2,  9,  1,  0],   // Steep Incline
      [  8,  1,  1,  5,  5, -6],   // Downhill Rush
      [  1,  2,  8, -3, 10,  3],   // Zigzag
      [  1,  5,  1,  2,  6, -8],   // Thunderstorm
      [ -5,  7, -3,  9,  2, -2],   // Sand Dunes
      [  3,  5,  2,  1,  6, -7],   // Night Trail
    ];

    const STAT_NAMES = ['SPD', 'STA', 'ACC', 'STR', 'AGI', 'TMP'];
    const STAT_FULL = ['SPEED', 'STAMINA', 'ACCEL', 'STRENGTH', 'AGILITY', 'TEMPER'];

    // ======== CONTRACT CONFIG ========
    const CONTRACT_ADDRESS = '0xC806442E60d3a807a316f3dCD81378E5B6Fe6a64';
    const MONAD_CHAIN_ID = '0x8F'; // 143
    const MONAD_RPC = 'https://rpc.monad.xyz';
    const ALCHEMY_RPC = 'https://monad-mainnet.g.alchemy.com/v2/GuQROHBRDBM1TNytlqOs9';
    const WALLETCONNECT_PROJECT_ID = '83e6999ad193280ea7045f3676eed19e';
    const CONTRACT_ABI = [
      // View functions
      'function getCurrentRaceId() view returns (uint256)',
      'function getRaceStartTime(uint256 raceId) view returns (uint256)',
      'function getRacePhase(uint256 raceId) view returns (uint8)',
      'function isBettingOpen(uint256 raceId) view returns (bool)',
      'function isSwitchingOpen(uint256 raceId) view returns (bool)',
      'function getPhaseTimeRemaining(uint256 raceId) view returns (uint256)',
      'function getRaceInfo(uint256 raceId) view returns (uint8 phase, address token, uint256 totalPool, uint8 numBulls, bool resolved, bool cancelled)',
      'function getRaceResults(uint256 raceId) view returns (uint8[8] finishOrder, uint256[8] finishTimes, uint32 resolvedAt)',
      'function getRaceSeedData(uint256 raceId) view returns (uint8[48] stats, uint8 trackType, bytes32 seed, bool seeded)',
      'function getTrackMultipliers(uint8 trackType) view returns (int8[6])',
      'function getEntropyFee() view returns (uint128)',
      'function entropy() view returns (address)',
      'function requestRaceSeed(uint256 raceId) payable',
      'function getRaceSeeder(uint256 raceId) view returns (address)',
      'function getSeederBalance(address seeder, address token) view returns (uint256)',
      'function claimSeederReward(address token)',
      'function resolveRace(uint256 raceId)',
      'function getBullPool(uint256 raceId, uint8 bullId) view returns (uint256)',
      'function getAllBullPools(uint256 raceId) view returns (uint256[8])',
      'function getUserBet(uint256 raceId, address user) view returns (bool exists, uint8 bullId, uint256 amount, bool claimed)',
      'function getPotentialPayout(uint256 raceId, uint8 bullId, uint256 amount) view returns (uint256)',
      'function getAcceptedTokens() view returns (address[])',
      'function minBetAmount(address token) view returns (uint256)',
      'function epoch() view returns (uint256)',
      'function cycleDuration() view returns (uint256)',
      'function bettingDuration() view returns (uint256)',
      'function switchingEnd() view returns (uint256)',
      // Write functions
      'function placeBet(uint256 raceId, uint8 bullId, address token, uint256 amount) payable',
      'function switchBet(uint256 raceId, uint8 newBullId)',
      'function claimWinnings(uint256 raceId)',
      'function claimRefund(uint256 raceId)',
      // Events
      'event BetPlaced(uint256 indexed raceId, address indexed bettor, uint8 bullId, address token, uint256 amount)',
      'event BetSwitched(uint256 indexed raceId, address indexed bettor, uint8 oldBullId, uint8 newBullId, uint256 fee)',
      'event RaceResolved(uint256 indexed raceId, uint8[8] finishOrder, uint256[8] finishTimes, uint256 totalPool)',
      'event WinningsClaimed(uint256 indexed raceId, address indexed bettor, uint256 payout)',
      'event RefundClaimed(uint256 indexed raceId, address indexed bettor, uint256 amount)',
    ];

    // Web3 state
    let provider = null;
    let signer = null;
    const readProvider = new ethers.JsonRpcProvider(ALCHEMY_RPC);
    const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, readProvider);
    let contractWrite = null;  // write (signer)
    let userAddress = null;

    // ======== APPKIT INITIALIZATION ========
    const monadMainnet = {
      id: 143,
      chainId: 143,
      name: 'Monad',
      currency: 'MON',
      explorerUrl: 'https://monadexplorer.com',
      rpcUrl: ALCHEMY_RPC,
      chainNamespace: 'eip155',
    };

    const wagmiAdapter = new WagmiAdapter({
      projectId: WALLETCONNECT_PROJECT_ID,
      networks: [monadMainnet],
    });

    const appKitModal = createAppKit({
      adapters: [wagmiAdapter],
      networks: [monadMainnet],
      projectId: WALLETCONNECT_PROJECT_ID,
      metadata: {
        name: 'Moonad',
        description: 'Bull Racing on Monad',
        url: 'https://www.moonad.fun',
        icons: [],
      },
      features: {
        email: false,
        socials: false,
        emailShowWallets: false,
      },
      enableAuthProvider: false,
      themeMode: 'dark',
      themeVariables: {
        '--w3m-accent': '#33ff00',
        '--w3m-border-radius-master': '0px',
        '--w3m-font-family': "'JetBrains Mono', 'Fira Code', monospace",
        '--w3m-z-index': 200,
      },
    });

    // AppKit EIP-1193 provider reference
    let appKitEip155Provider = null;
    let _appKitSettingUp = false;

    // Subscribe to provider events — capture the EIP-1193 provider when available
    appKitModal.subscribeProviders(providers => {
      if (providers && providers['eip155']) {
        appKitEip155Provider = providers['eip155'];
      }
    });

    // Subscribe to connection state changes
    appKitModal.subscribeState(async state => {
      if (state.selectedNetworkId && appKitEip155Provider && !RM.walletConnected && !_appKitSettingUp) {
        await setupEthersFromAppKit();
      }
    });

    // Also listen for account changes
    appKitModal.subscribeAccount && appKitModal.subscribeAccount(async account => {
      if (account && account.address && appKitEip155Provider && !RM.walletConnected && !_appKitSettingUp) {
        await setupEthersFromAppKit();
      } else if (account && !account.address && RM.walletConnected) {
        teardownWallet();
      }
    });

    async function setupEthersFromAppKit() {
      if (_appKitSettingUp) return;
      _appKitSettingUp = true;
      try {
        if (!appKitEip155Provider) { _appKitSettingUp = false; return; }
        provider = new ethers.BrowserProvider(appKitEip155Provider, 143);
        signer = await provider.getSigner();
        userAddress = await signer.getAddress();
        contractWrite = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

        const bal = await provider.getBalance(userAddress);
        RM.walletBalance = parseFloat(ethers.formatEther(bal));
        RM.walletConnected = true;

        const btn = document.getElementById('wallet-btn');
        const short = userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
        btn.textContent = `${short} | ${RM.walletBalance.toFixed(1)} MON`;
        btn.classList.add('connected');

        SFX.walletConnect();
        updateBalanceDisplay();
        updateClaimBanner();
        syncToLivePhase();
        console.log('[AppKit] Wallet connected:', userAddress);
      } catch (err) {
        console.error('[AppKit] setupEthersFromAppKit failed:', err);
      } finally {
        _appKitSettingUp = false;
      }
    }

    function teardownWallet() {
      RM.walletConnected = false;
      userAddress = null;
      signer = null;
      provider = null;
      contractWrite = null;
      appKitEip155Provider = null;

      const btn = document.getElementById('wallet-btn');
      btn.textContent = '[ CONNECT WALLET ]';
      btn.classList.remove('connected');
      updateBalanceDisplay();
      updateClaimBanner();
      console.log('[AppKit] Wallet disconnected');
    }

    // ======== TYPEWRITER TEXT EFFECT ========
    let _typewriterTimeout = null;
    function typeText(el, text, speed = 50) {
      if (_typewriterTimeout) { clearTimeout(_typewriterTimeout); _typewriterTimeout = null; }
      el.textContent = '';
      el.style.display = 'block';
      el.classList.remove('hidden');
      let i = 0;
      function tick() {
        if (i < text.length) {
          el.textContent = text.substring(0, i + 1);
          if (typeof SFX !== 'undefined') SFX.typeKey();
          i++;
          _typewriterTimeout = setTimeout(tick, speed);
        }
      }
      tick();
    }

    const bullColors = [
      { name: 'Crimson Thunder', wire: 0xff3333, dot: '#ff3333' },
      { name: 'Midnight Storm',  wire: 0x00ccff, dot: '#00ccff' },
      { name: 'Scarlet Blaze',   wire: 0xff6600, dot: '#ff6600' },
      { name: 'Emerald Fury',    wire: 0x33ff00, dot: '#33ff00' },
      { name: 'Golden Horns',    wire: 0xffdd00, dot: '#ffdd00' },
      { name: 'Silver Bullet',   wire: 0xffffff, dot: '#ffffff' },
      { name: 'Violet Charge',   wire: 0xcc33ff, dot: '#cc33ff' },
      { name: 'Copper Beast',    wire: 0xff66aa, dot: '#ff66aa' },
    ];

    // ======== RACE MANAGER STATE ========
    const RM = {
      phase: 'loading',   // loading | waiting | betting | revealing | switching | racing | results
      raceId: 0,
      phaseStart: 0,
      bullStats: [],       // [8][6] stats 1-10
      trackType: -1,
      scores: [],
      finishOrder: [],
      // Betting state
      myBet: null,         // { bullIndex, amount }
      bullPools: {},       // bullIndex → total MON (on-chain pool data)
      walletBalance: 0,
      walletConnected: false,
      switchMode: false,   // true when user is picking a new bull to switch to
      seeded: false,       // whether current race has VRF seed
    };

    // ======== SCENE ========
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.004);

    const camera = new THREE.PerspectiveCamera(65, innerWidth / innerHeight, 0.1, 600);
    camera.position.set(-12, 6, 12);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = false;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 1.5, 0);
    controls.maxDistance = 60;
    controls.minDistance = 2;
    controls.enabled = false;

    // Camera mode
    let camMode = 'chase';
    function updateCamButtons() {
      document.querySelectorAll('#cam-controls button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === camMode);
      });
      const info = document.getElementById('cam-mode-info');
      if (info) info.textContent = 'CAM: ' + camMode.toUpperCase();
    }
    document.querySelectorAll('#cam-controls button').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        camMode = btn.dataset.mode;
        controls.enabled = (camMode === 'free');
        updateCamButtons();
      });
    });
    renderer.domElement.addEventListener('pointerdown', () => {
      if (camMode !== 'free') { camMode = 'free'; controls.enabled = true; updateCamButtons(); }
    }, true);
    renderer.domElement.addEventListener('wheel', () => {
      if (camMode !== 'free') { camMode = 'free'; controls.enabled = true; updateCamButtons(); }
    }, true);

    const keysPressed = new Set();
    const moveKeys = ['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'];
    addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      if (e.key === 'Escape') { closeBettingPanel(); closeBetModal(); hideBullStatPopup(); return; }
      // Carousel navigation when betting panel is open
      if (bettingPanelOpen && (key === 'arrowleft' || key === 'arrowright')) {
        e.preventDefault();
        if (key === 'arrowleft') prevBull();
        else nextBull();
        return;
      }
      if (moveKeys.includes(key)) {
        keysPressed.add(key);
        if (camMode !== 'free') { camMode = 'free'; controls.enabled = true; updateCamButtons(); }
      }
    });
    addEventListener('keyup', (e) => keysPressed.delete(e.key.toLowerCase()));

    // ======== LIGHTING ========
    scene.add(new THREE.AmbientLight(0x33ff00, 0.8));
    const sun = new THREE.DirectionalLight(0x33ff00, 0.5);
    sun.position.set(10, 15, 8);
    scene.add(sun);

    // ======== TRACK & ENVIRONMENT ========
    const trackWidth = NUM_BULLS * LANE_WIDTH + 2;
    const TRACK_LEN = 600;

    const gridHelper = new THREE.GridHelper(TRACK_LEN, TRACK_LEN / 2, 0x1f521f, 0x0a2a0a);
    gridHelper.position.x = FINISH_X / 2;
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.4;
    scene.add(gridHelper);

    const trackGrid = new THREE.GridHelper(TRACK_LEN, TRACK_LEN / 2, 0x33ff00, 0x1f521f);
    trackGrid.position.x = FINISH_X / 2;
    trackGrid.position.y = 0.005;
    trackGrid.material.transparent = true;
    trackGrid.material.opacity = 0.15;
    scene.add(trackGrid);

    const laneMat = new THREE.LineBasicMaterial({ color: 0x33ff00, transparent: true, opacity: 0.7 });
    for (let lane = 0; lane <= NUM_BULLS; lane++) {
      const z = (lane - NUM_BULLS / 2) * LANE_WIDTH;
      const pts = [new THREE.Vector3(-10, 0.02, z), new THREE.Vector3(FINISH_X + 50, 0.02, z)];
      scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), laneMat));
    }

    // Track-side markers
    const markerGreenMat = new THREE.MeshBasicMaterial({ color: 0x33ff00, wireframe: true });
    const markerPostGeo = new THREE.CylinderGeometry(0.08, 0.08, 2.0, 4);
    const markerTopGeo = new THREE.OctahedronGeometry(0.15, 0);
    for (let x = 0; x <= FINISH_X + 20; x += 10) {
      for (let side = -1; side <= 1; side += 2) {
        const post = new THREE.Mesh(markerPostGeo, markerGreenMat);
        post.position.set(x, 1.0, side * (trackWidth / 2 + 1.5));
        scene.add(post);
        const top = new THREE.Mesh(markerTopGeo, markerGreenMat);
        top.position.set(x, 2.1, side * (trackWidth / 2 + 1.5));
        scene.add(top);
      }
    }

    // Distance signs
    for (let x = 50; x <= FINISH_X; x += 50) {
      for (let side = -1; side <= 1; side += 2) {
        const signCanvas = document.createElement('canvas');
        signCanvas.width = 64; signCanvas.height = 32;
        const sCtx = signCanvas.getContext('2d');
        sCtx.fillStyle = '#000000'; sCtx.fillRect(0, 0, 64, 32);
        sCtx.strokeStyle = '#33ff00'; sCtx.lineWidth = 1; sCtx.strokeRect(1, 1, 62, 30);
        sCtx.fillStyle = '#33ff00'; sCtx.font = 'bold 20px monospace';
        sCtx.textAlign = 'center'; sCtx.textBaseline = 'middle';
        sCtx.fillText(`${x}M`, 32, 16);
        const signTex = new THREE.CanvasTexture(signCanvas);
        const signPlane = new THREE.Mesh(
          new THREE.PlaneGeometry(0.8, 0.4),
          new THREE.MeshBasicMaterial({ map: signTex, transparent: true })
        );
        signPlane.position.set(x, 2.4, side * (trackWidth / 2 + 1.5));
        signPlane.rotation.y = side > 0 ? -Math.PI / 2 : Math.PI / 2;
        scene.add(signPlane);
      }
    }

    // Ground chevrons
    const chevronMat = new THREE.LineBasicMaterial({ color: 0x33ff00, transparent: true, opacity: 0.06 });
    for (let x = 0; x <= FINISH_X + 20; x += 5) {
      const pts = [new THREE.Vector3(x, 0.01, -trackWidth * 0.3), new THREE.Vector3(x, 0.01, trackWidth * 0.3)];
      scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), chevronMat));
    }

    // Fences
    const FENCE_COUNT = 250;
    const fencePostGeo = new THREE.BoxGeometry(0.06, 1.0, 0.06);
    const fenceRailGeo = new THREE.BoxGeometry(2.5, 0.04, 0.04);
    const fenceMat = new THREE.MeshBasicMaterial({ color: 0x1f521f, wireframe: true });
    for (let side = -1; side <= 1; side += 2) {
      const z = side * (trackWidth / 2 + 2.5);
      const posts = new THREE.InstancedMesh(fencePostGeo, fenceMat, FENCE_COUNT);
      const rails1 = new THREE.InstancedMesh(fenceRailGeo, fenceMat, FENCE_COUNT - 1);
      const rails2 = new THREE.InstancedMesh(fenceRailGeo, fenceMat, FENCE_COUNT - 1);
      const m = new THREE.Matrix4();
      for (let i = 0; i < FENCE_COUNT; i++) {
        m.makeTranslation(-10 + i * 2.5, 0.5, z); posts.setMatrixAt(i, m);
        if (i < FENCE_COUNT - 1) {
          m.makeTranslation(-10 + i * 2.5 + 1.25, 0.75, z); rails1.setMatrixAt(i, m);
          m.makeTranslation(-10 + i * 2.5 + 1.25, 0.35, z); rails2.setMatrixAt(i, m);
        }
      }
      scene.add(posts, rails1, rails2);
    }

    // Trees
    const treeWireMat = new THREE.MeshBasicMaterial({ color: 0x1f521f, wireframe: true });
    const treeGlowMat = new THREE.MeshBasicMaterial({ color: 0x33ff00, wireframe: true, transparent: true, opacity: 0.3 });
    for (let side = -1; side <= 1; side += 2) {
      for (let i = 0; i < 80; i++) {
        const g = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.12, 1.5, 4), treeWireMat);
        trunk.position.y = 0.75; g.add(trunk);
        const crownGeo = Math.random() > 0.5 ? new THREE.IcosahedronGeometry(0.7 + Math.random() * 0.5, 0) : new THREE.OctahedronGeometry(0.6 + Math.random() * 0.4, 0);
        const crown = new THREE.Mesh(crownGeo, Math.random() > 0.3 ? treeWireMat : treeGlowMat);
        crown.position.y = 1.8 + Math.random() * 0.5;
        crown.rotation.y = Math.random() * Math.PI; g.add(crown);
        g.position.set(-20 + i * 7 + Math.random() * 4, 0, side * (trackWidth / 2 + 5 + Math.random() * 15));
        g.scale.setScalar(0.6 + Math.random() * 1.0);
        scene.add(g);
      }
    }

    // Start gate
    const startGateMat = new THREE.MeshBasicMaterial({ color: 0x33ff00, wireframe: true });
    const sp1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 3.5, 0.15), startGateMat);
    sp1.position.set(0, 1.75, -trackWidth / 2 - 2); scene.add(sp1);
    const sp2 = sp1.clone(); sp2.position.z = trackWidth / 2 + 2; scene.add(sp2);
    const startBar = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, trackWidth + 4.2), startGateMat);
    startBar.position.set(0, 3.5, 0); scene.add(startBar);
    const startLineMat = new THREE.LineBasicMaterial({ color: 0x33ff00 });
    for (let z = -trackWidth / 2; z <= trackWidth / 2; z += 0.5) {
      const pts = [new THREE.Vector3(-0.5, 0.02, z), new THREE.Vector3(0.5, 0.02, z)];
      scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), startLineMat));
    }

    // Finish gate
    const finishGateMat = new THREE.MeshBasicMaterial({ color: 0xffb000, wireframe: true });
    const fp1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4.5, 0.2), finishGateMat);
    fp1.position.set(FINISH_X, 2.25, -trackWidth / 2 - 2); scene.add(fp1);
    const fp2 = fp1.clone(); fp2.position.z = trackWidth / 2 + 2; scene.add(fp2);
    const finishBar = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.35, trackWidth + 4.2), finishGateMat);
    finishBar.position.set(FINISH_X, 4.5, 0); scene.add(finishBar);
    const finTextCanvas = document.createElement('canvas');
    finTextCanvas.width = 512; finTextCanvas.height = 64;
    const ftCtx = finTextCanvas.getContext('2d');
    ftCtx.fillStyle = '#000000'; ftCtx.fillRect(0, 0, 512, 64);
    ftCtx.fillStyle = '#ffb000'; ftCtx.font = 'bold 42px monospace';
    ftCtx.textAlign = 'center'; ftCtx.textBaseline = 'middle';
    ftCtx.fillText('> F I N I S H _', 256, 32);
    const finTextTex = new THREE.CanvasTexture(finTextCanvas);
    for (let rot of [Math.PI / 2, -Math.PI / 2]) {
      const plane = new THREE.Mesh(new THREE.PlaneGeometry(trackWidth + 4, 0.6), new THREE.MeshBasicMaterial({ map: finTextTex, transparent: true }));
      plane.position.set(FINISH_X, 4.8, 0); plane.rotation.y = rot; scene.add(plane);
    }
    const finLineMat = new THREE.LineBasicMaterial({ color: 0xffb000, transparent: true, opacity: 0.5 });
    for (let z = -trackWidth / 2; z <= trackWidth / 2; z += 0.5) {
      const pts = [new THREE.Vector3(FINISH_X - 1, 0.02, z), new THREE.Vector3(FINISH_X + 1, 0.02, z)];
      scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), finLineMat));
    }

    // ======== PARTICLES ========
    const dustCount = 300;
    const dustPos = new Float32Array(dustCount * 3);
    const dustVel = [];
    for (let i = 0; i < dustCount; i++) { dustPos[i * 3 + 1] = -10; dustVel.push({ x: 0, y: 0, z: 0, life: 0 }); }
    const dustGeo = new THREE.BufferGeometry();
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    scene.add(new THREE.Points(dustGeo, new THREE.PointsMaterial({ color: 0x33ff00, size: 0.1, transparent: true, opacity: 0.4 })));
    let dustIdx = 0;
    function emitDust(px, py, pz, speed) {
      const count = Math.max(1, Math.floor(speed * 0.8));
      for (let k = 0; k < count; k++) {
        const i = dustIdx++ % dustCount;
        dustPos[i * 3] = px + (Math.random() - 0.5) * 0.4;
        dustPos[i * 3 + 1] = py + 0.05;
        dustPos[i * 3 + 2] = pz + (Math.random() - 0.5) * 0.4;
        dustVel[i] = { x: -speed * 0.4 + Math.random() * 0.5, y: 0.4 + Math.random() * 0.6, z: (Math.random() - 0.5) * 1.0, life: 0.8 + Math.random() * 0.5 };
      }
    }

    const speedLineCount = 120;
    const slPositions = new Float32Array(speedLineCount * 3);
    const slVelocities = [];
    for (let i = 0; i < speedLineCount; i++) {
      slPositions[i * 3] = Math.random() * 40 - 20;
      slPositions[i * 3 + 1] = 0.3 + Math.random() * 4;
      slPositions[i * 3 + 2] = (Math.random() - 0.5) * 30;
      slVelocities.push(-8 - Math.random() * 5);
    }
    const slGeo = new THREE.BufferGeometry();
    slGeo.setAttribute('position', new THREE.BufferAttribute(slPositions, 3));
    const speedLines = new THREE.Points(slGeo, new THREE.PointsMaterial({ color: 0x33ff00, size: 0.04, transparent: true, opacity: 0.35, sizeAttenuation: true }));
    scene.add(speedLines);

    // ======== LOAD MODEL (ONCE) ========
    const clock = new THREE.Clock();
    let bulls = [];
    let raceStarted = false;
    let raceStartTime = 0;
    let countdownStarted = false;
    let nextRank = 1;
    let raceOver = false;

    // Stored model reference for cloning
    let loadedModel = null;
    let loadedAnimations = null;
    let modelScale = 1;
    let bestRotY = -Math.PI / 2;

    // ======== BULL PREVIEW RENDERER ========
    const PREVIEW_W = 180, PREVIEW_H = 200;
    const previewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    previewRenderer.setSize(PREVIEW_W, PREVIEW_H);
    previewRenderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    previewRenderer.setClearColor(0x0a0a0a, 1);
    const previewScene = new THREE.Scene();
    previewScene.add(new THREE.AmbientLight(0xffffff, 1.2));
    const previewDirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    previewDirLight.position.set(3, 4, 2);
    previewScene.add(previewDirLight);
    const previewCam = new THREE.PerspectiveCamera(35, PREVIEW_W / PREVIEW_H, 0.1, 50);
    let previewBullMesh = null;
    let previewMixer = null;

    function renderBullPreview(bullIndex, container) {
      if (!loadedModel) return;
      // Clean up previous preview
      if (previewBullMesh) { previewScene.remove(previewBullMesh); previewBullMesh = null; }
      if (previewMixer) { previewMixer.stopAllAction(); previewMixer = null; }

      const clone = SkeletonUtils.clone(loadedModel);
      clone.scale.setScalar(modelScale);
      clone.rotation.y = bestRotY;
      const bc = bullColors[bullIndex];
      clone.traverse(child => {
        if (child.isMesh) {
          child.material = new THREE.MeshBasicMaterial({
            color: bc.wire, wireframe: true, transparent: true, opacity: 0.9,
          });
        }
      });

      // Play walk/trot animation so the bull is visibly moving
      const mixer = new THREE.AnimationMixer(clone);
      if (loadedAnimations) {
        const walkClip = loadedAnimations.find(c => c.name.includes('Walk_F_RM'))
          || loadedAnimations.find(c => c.name.includes('Trot_F_RM'))
          || loadedAnimations.find(c => c.name.includes('Idle_1'))
          || loadedAnimations[0];
        if (walkClip) {
          const clip = stripRootMotion(walkClip);
          const action = mixer.clipAction(clip);
          action.timeScale = 0.8;
          action.play();
          mixer.setTime(Math.random() * clip.duration);
        }
      }
      previewMixer = mixer;

      previewScene.add(clone);
      previewBullMesh = clone;

      // Center and frame the bull
      clone.updateMatrixWorld(true);
      const box = new THREE.Box3().setFromObject(clone);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      clone.position.y -= box.min.y;
      clone.position.x -= center.x;
      clone.position.z -= center.z;

      previewCam.position.set(size.x * 1.2, size.y * 0.6, size.x * 1.5);
      previewCam.lookAt(0, size.y * 0.4, 0);

      previewRenderer.render(previewScene, previewCam);
      container.innerHTML = '';
      container.appendChild(previewRenderer.domElement);
    }

    // Animate preview bull in the render loop
    function updateBullPreview(dt) {
      if (previewMixer && bettingPanelOpen) {
        previewMixer.update(dt);
        // Slow turntable rotation
        if (previewBullMesh) {
          previewBullMesh.rotation.y += dt * 0.3;
        }
        previewRenderer.render(previewScene, previewCam);
      }
    }

    function stripRootMotion(clip) {
      clip.tracks = clip.tracks.filter(track => !(track.name.includes('root_bone') && track.name.endsWith('.position')));
      return clip;
    }

    // ======== SCORE COMPUTATION ========
    function computeScore(stats, trackType) {
      const mults = TRACK_MULTIPLIERS[trackType];
      let score = 0;
      for (let i = 0; i < 6; i++) {
        if (i === 5) {
          score += (stats[5] - 5) * mults[5]; // temper offset
        } else {
          score += stats[i] * mults[i];
        }
      }
      // noise ±15
      score += Math.floor(Math.random() * 31) - 15;
      return score;
    }

    // ======== GENERATE RACE DATA ========
    function generateRaceData() {
      RM.myBet = null;
      RM.bullPools = {};
      loadLiveRaceData();
    }

    async function loadLiveRaceData() {
      try {
        const raceId = await contract.getCurrentRaceId();
        RM.liveRaceId = raceId;
        const seedData = await contract.getRaceSeedData(raceId);
        if (seedData.seeded) {
          RM.seeded = true;
          // Unpack 48-element flat array into 8 bulls × 6 stats
          RM.bullStats = [];
          for (let i = 0; i < NUM_BULLS; i++) {
            const stats = [];
            for (let s = 0; s < 6; s++) stats.push(Number(seedData.stats[i * 6 + s]));
            RM.bullStats.push(stats);
          }
          RM.trackType = Number(seedData.trackType);
          updateSeedButton();
        } else {
          RM.seeded = false;
          // Not seeded yet — use placeholder stats, will refresh when seeded
          RM.bullStats = [];
          for (let i = 0; i < NUM_BULLS; i++) {
            RM.bullStats.push([5, 5, 5, 5, 5, 5]);
          }
          RM.trackType = 0;
          updateSeedButton();
        }
        // Load on-chain pool data
        const pools = await contract.getAllBullPools(raceId);
        RM.bullPools = {};
        for (let i = 0; i < NUM_BULLS; i++) {
          RM.bullPools[i] = Number(ethers.formatEther(pools[i]));
        }
        liveRaceDataLoaded = true;
      } catch (e) {
        console.error('Failed to load live race data:', e);
        RM.seeded = false;
        RM.bullStats = [];
        for (let i = 0; i < NUM_BULLS; i++) {
          RM.bullStats.push([5, 5, 5, 5, 5, 5]);
        }
        RM.trackType = 0;
        updateSeedButton();
        liveRaceDataLoaded = true;
      }
    }

    // ======== SEED BUTTON ========

    function updateSeedButton() {
      const btn = document.getElementById('seed-btn');
      const live = getLiveState();
      // Show seed button only during BETTING/SWITCHING if not yet seeded
      if (!RM.seeded && (live.contractPhase === 'BETTING' || live.contractPhase === 'SWITCHING')) {
        btn.classList.add('visible');
        btn.classList.remove('hidden');
      } else {
        btn.classList.remove('visible');
        btn.classList.add('hidden');
      }
    }

    function onSeedArrived() {
      SFX.phaseChange();
      const pd = document.getElementById('phase-display');
      typeText(pd, '> BULLS GENERATED — PLACE YOUR BETS', 30);
      setTimeout(() => { pd.classList.add('hidden'); }, 3000);
      if (RM.phase === 'betting' || RM.phase === 'switching') {
        renderBullCards();
        updatePoolDisplay();
        if (document.getElementById('betting-panel').classList.contains('visible')) {
          renderBettingPanel();
        }
        if (loadedModel && bulls.length === 0) spawnBulls();
      }
    }

    window.seedRace = async function() {
      if (RM.seeded) return;
      if (!contractWrite) {
        SFX.error();
        alert('Connect wallet to seed the race');
        return;
      }
      const btn = document.getElementById('seed-btn');
      btn.textContent = '[ SEEDING... ]';
      btn.style.pointerEvents = 'none';
      try {
        const fee = await contract.getEntropyFee();
        const tx = await contractWrite.requestRaceSeed(RM.raceId, { value: fee });
        await tx.wait();
        SFX.confirm();
        btn.textContent = '[ SEED REQUESTED ]';
        // Poll for seed to arrive (VRF callback)
        let attempts = 0;
        const seedPoll = setInterval(async () => {
          attempts++;
          try {
            const seedData = await contract.getRaceSeedData(RM.raceId);
            if (seedData.seeded) {
              clearInterval(seedPoll);
              await loadLiveRaceData();
              onSeedArrived();
            }
          } catch (e) {}
          if (attempts > 30) clearInterval(seedPoll); // give up after 5min
        }, 10000);
      } catch (err) {
        SFX.error();
        console.error('Seed failed:', err);
        btn.textContent = '[ SEED RACE ]';
        btn.style.pointerEvents = '';
        alert('Seed failed: ' + (err.reason || err.message || 'unknown error'));
      }
    };

    // ======== LIVE MODE TIMING ========

    /** Compute current race phase from UTC time (mirrors contract logic exactly) */
    function getLiveState() {
      const now = Math.floor(Date.now() / 1000);
      if (now < liveEpoch) return { raceId: 0, contractPhase: 'BETTING', remaining: 0, elapsed: 0 };
      const raceId = Math.floor((now - liveEpoch) / liveCycleDuration);
      const raceStart = liveEpoch + raceId * liveCycleDuration;
      const elapsed = now - raceStart;

      let contractPhase, remaining;
      if (elapsed < liveBettingDuration) {
        contractPhase = 'BETTING';
        remaining = liveBettingDuration - elapsed;
      } else if (elapsed < liveSwitchingEnd) {
        contractPhase = 'SWITCHING';
        remaining = liveSwitchingEnd - elapsed;
      } else {
        contractPhase = 'CLOSED';
        remaining = liveCycleDuration - elapsed;
      }

      return { raceId, contractPhase, remaining, elapsed };
    }

    /** Load contract timing config once */
    async function loadLiveConfig() {
      if (liveConfigLoaded) return;
      try {
        const [ep, cycle, betting, switching] = await Promise.all([
          contract.epoch(),
          contract.cycleDuration(),
          contract.bettingDuration(),
          contract.switchingEnd(),
        ]);
        liveEpoch = Number(ep);
        liveCycleDuration = Number(cycle);
        liveBettingDuration = Number(betting);
        liveSwitchingEnd = Number(switching);
        liveConfigLoaded = true;
        console.log(`Live config: epoch=${liveEpoch}, cycle=${liveCycleDuration}s, betting=${liveBettingDuration}s, switchEnd=${liveSwitchingEnd}s`);
      } catch (e) {
        console.error('Failed to load live config:', e);
      }
    }

    /** Sync frontend to correct on-chain phase (called when entering LIVE mode) */
    async function syncToLivePhase() {

      await loadLiveConfig();
      const live = getLiveState();
      RM.liveRaceId = live.raceId;
      RM.raceId = live.raceId;

      document.querySelector('#title-bar .title-text').textContent = `> MOONAD // LIVE RACE #${RM.raceId}`;

      // Load on-chain data for this race
      RM.myBet = null;
      RM.bullPools = {};
      await loadLiveRaceData();
      liveRaceDataLoaded = true;

      // Load user's existing bet if wallet connected
      if (userAddress) {
        try {
          const bet = await contract.getUserBet(live.raceId, userAddress);
          if (bet.exists) {
            RM.myBet = { bullIndex: Number(bet.bullId), amount: Number(ethers.formatEther(bet.amount)) };
          }
        } catch (e) {}
      }

      // Map contract phase to correct frontend phase (skip animations for mid-cycle join)
      switch (live.contractPhase) {
        case 'BETTING':
          setPhase('betting');
          break;
        case 'SWITCHING':
          setPhase('switching');
          break;
        case 'CLOSED':
          try {
            const info = await contract.getRaceInfo(live.raceId);
            if (info.resolved) {
              const results = await contract.getRaceResults(live.raceId);
              RM.finishOrder = Array.from(results.finishOrder).map(Number);
              // Build scores indexed by bull ID (higher = better)
              RM.scores = new Array(NUM_BULLS).fill(0);
              for (let r = 0; r < NUM_BULLS; r++) RM.scores[RM.finishOrder[r]] = NUM_BULLS - r;
              setPhase('results');
            } else if (live.remaining > 200) {
              computeRaceResults();
              setPhase('racing');
            } else {
              computeRaceResults();
              setPhase('results');
            }
          } catch (e) {
            computeRaceResults();
            setPhase('results');
          }
          break;
      }

      startLivePolling();
    }

    /** Poll contract for pool/bet data updates */
    function startLivePolling() {
      stopLivePolling();
      livePollInterval = setInterval(async () => {
        try {
          const live = getLiveState();
          if (live.raceId !== RM.liveRaceId) return; // Race changed, phase transition handles it

          // If not seeded yet, check for seed arrival
          if (!RM.seeded) {
            const seedData = await contract.getRaceSeedData(live.raceId);
            if (seedData.seeded) {
              await loadLiveRaceData();
              onSeedArrived();
            }
          }

          const pools = await contract.getAllBullPools(live.raceId);
          RM.bullPools = {};
          for (let i = 0; i < NUM_BULLS; i++) {
            RM.bullPools[i] = Number(ethers.formatEther(pools[i]));
          }
          if (userAddress) {
            const bet = await contract.getUserBet(live.raceId, userAddress);
            if (bet.exists) {
              RM.myBet = { bullIndex: Number(bet.bullId), amount: Number(ethers.formatEther(bet.amount)) };
            }
          }
          updatePoolDisplay();
          if (RM.phase === 'betting' || RM.phase === 'switching') renderBullCards();
        } catch (e) {
          console.error('Live poll error:', e);
        }
      }, 10000);
    }

    function stopLivePolling() {
      if (livePollInterval) {
        clearInterval(livePollInterval);
        livePollInterval = null;
      }
    }

    function computeRaceResults() {
      RM.scores = [];
      for (let i = 0; i < NUM_BULLS; i++) {
        RM.scores.push(computeScore(RM.bullStats[i], RM.trackType));
      }
      // Sort indices by score descending
      RM.finishOrder = Array.from({ length: NUM_BULLS }, (_, i) => i);
      RM.finishOrder.sort((a, b) => RM.scores[b] - RM.scores[a]);
    }

    // ======== UI RENDERING ========
    function renderBullCards() {
      const container = document.getElementById('bull-cards');
      container.innerHTML = '';
      for (let i = 0; i < NUM_BULLS; i++) {
        const stats = RM.bullStats[i];
        const bc = bullColors[i];
        const pool = getTotalPoolForBull(i);
        const totalPool = getTotalPool();
        const odds = pool > 0 ? (totalPool / pool * 0.9).toFixed(1) : '--';

        let barsHtml = '';
        for (let s = 0; s < 6; s++) {
          const val = stats[s];
          const filled = '|'.repeat(val);
          const empty = '\u00B7'.repeat(10 - val);
          const color = s === 5 ? (val >= 7 ? 'var(--error)' : val <= 3 ? 'var(--primary)' : bc.dot) : bc.dot;
          barsHtml += `<div class="stat-row">
            <span class="stat-label">${STAT_FULL[s]}</span>
            <span class="stat-bar-ascii" style="color:${color}">${filled}<span style="color:var(--muted)">${empty}</span></span>
            <span class="stat-val">${val}</span>
          </div>`;
        }

        const isMyBet = RM.myBet && RM.myBet.bullIndex === i;
        const card = document.createElement('div');
        card.className = 'bull-card' + (isMyBet ? ' selected' : '');

        let cardBtnHtml;
        if (RM.switchMode && RM.myBet) {
          if (isMyBet) {
            cardBtnHtml = `<button class="bet-btn placed">[ CURRENT ]</button>`;
          } else {
            cardBtnHtml = `<button class="bet-btn" style="border-color:var(--secondary);color:var(--secondary)" onclick="confirmSwitch(${i})">[ SWITCH ]</button>`;
          }
        } else {
          cardBtnHtml = `<button class="bet-btn ${isMyBet ? 'placed' : ''}" onclick="openBetModal(${i})">${isMyBet ? '[ BET PLACED ]' : '[ BET ]'}</button>`;
        }

        card.innerHTML = `
          <div class="card-name" style="color:${bc.dot}">${bc.name}</div>
          ${barsHtml}
          <div class="card-pool">
            <span>POOL: ${pool.toFixed(1)}</span>
            <span class="card-odds">${odds}x</span>
          </div>
          ${cardBtnHtml}
          <div class="warning-badge" id="warn-${i}"></div>
        `;
        container.appendChild(card);
      }
    }

    // ======== BETTING PANEL (CAROUSEL) ========
    let panelBullIndex = 0;
    let bettingPanelOpen = false;

    function renderBettingPanel() {
      const body = document.getElementById('betting-panel-body');
      const i = panelBullIndex;
      const stats = RM.bullStats[i];
      const bc = bullColors[i];
      const pool = getTotalPoolForBull(i);
      const totalPool = getTotalPool();
      const odds = pool > 0 ? (totalPool / pool * 0.9).toFixed(1) : '--';
      const isMyBet = RM.myBet && RM.myBet.bullIndex === i;

      // Update panel border color
      document.getElementById('betting-panel').style.borderColor = bc.dot;

      // Update counter
      const counter = document.getElementById('betting-panel-counter');
      if (counter) counter.textContent = `${i + 1}/${NUM_BULLS}`;

      // Stats
      let statsHtml = '<div class="carousel-stats">';
      for (let s = 0; s < 6; s++) {
        const val = stats[s];
        const filled = '|'.repeat(val);
        const empty = '\u00B7'.repeat(10 - val);
        const color = s === 5 ? (val >= 7 ? 'var(--error)' : val <= 3 ? 'var(--primary)' : bc.dot) : bc.dot;
        const warn = s === 5 && val >= 7 ? ' \u26A1' : '';
        statsHtml += `<div class="carousel-stat-line">
          <span class="stat-label">${STAT_FULL[s]}</span>
          <span class="stat-bar" style="color:${color}">${filled}<span style="color:#2a6b2a">${empty}</span></span>
          <span class="stat-val" style="color:${color}">${val}${warn}</span>
        </div>`;
      }
      statsHtml += '</div>';

      // Bet button
      let btnHtml = '';
      if (RM.switchMode && RM.myBet) {
        // Switch mode: show switch-to buttons
        if (isMyBet) {
          btnHtml = `<button class="carousel-bet-btn placed">[ CURRENT BET ]</button>`;
        } else {
          const remaining = (RM.myBet.amount * 0.95).toFixed(2);
          btnHtml = `<button class="carousel-bet-btn" style="border-color:var(--secondary);color:var(--secondary)" onclick="confirmSwitch(${i})">[ SWITCH TO ${bc.name.toUpperCase()} ]</button>`;
          btnHtml += `<div style="color:var(--muted);font-size:9px;margin-top:4px;text-align:center">5% fee \u2192 ${remaining} MON</div>`;
        }
      } else if (isMyBet) {
        btnHtml = `<button class="carousel-bet-btn placed">[ BET PLACED \u2713 ]</button>`;
        btnHtml += `<div style="color:var(--secondary);font-size:10px;margin-top:6px;text-align:center">YOUR BET: ${RM.myBet.amount.toFixed(2)} MON</div>`;
      } else if (!RM.myBet && RM.walletConnected) {
        btnHtml = `<button class="carousel-bet-btn" onclick="openBetModal(${i})">[ BET ON ${bc.name.toUpperCase()} ]</button>`;
      } else if (RM.myBet && RM.walletConnected) {
        btnHtml = `<button class="carousel-bet-btn" style="color:#555;border-color:#555;cursor:default">[ BET PLACED ON ${bullColors[RM.myBet.bullIndex].name.toUpperCase()} ]</button>`;
      } else {
        btnHtml = `<button class="carousel-bet-btn" style="color:#555;border-color:#555" onclick="connectWallet()">[ CONNECT WALLET ]</button>`;
      }

      body.innerHTML = `
        <div class="carousel-bull-header">
          <div class="color-block" style="background:${bc.dot}"></div>
          <span class="bull-name" style="color:${bc.dot}">${bc.name}</span>
        </div>
        <div class="carousel-content-row">
          <div class="carousel-bull-preview" id="bull-preview-container"></div>
          ${statsHtml}
        </div>
        <div class="carousel-pool-area">
          <span class="pool-label">POOL: ${pool.toFixed(1)} MON</span>
          <span class="pool-odds">${odds}x</span>
        </div>
        ${btnHtml}
      `;

      // Render 3D bull preview
      const previewContainer = document.getElementById('bull-preview-container');
      if (previewContainer) renderBullPreview(i, previewContainer);

      // Render indicator dots
      renderBullIndicators();
    }

    function renderBullIndicators() {
      const container = document.getElementById('bull-indicators');
      let html = '';
      for (let i = 0; i < NUM_BULLS; i++) {
        const bc = bullColors[i];
        const active = i === panelBullIndex ? ' active' : '';
        html += `<div class="bull-indicator${active}" style="background:${bc.dot}" onclick="goToBull(${i})"></div>`;
      }
      container.innerHTML = html;
    }

    function updateBettingPanelTimer() {
      const el = document.getElementById('betting-panel-timer');
      if (!el) return;
      const remaining = getPhaseTimeRemaining();
      const m = Math.floor(remaining / 60);
      const s = Math.floor(remaining % 60);
      const label = RM.phase === 'switching' ? 'switching closes' : 'betting closes';
      el.textContent = `${label}: ${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    window.openBettingPanel = function() {
      bettingPanelOpen = true;
      SFX.panelOpen();
      // If user has a bet, start on that bull; otherwise start at 0
      panelBullIndex = RM.myBet ? RM.myBet.bullIndex : 0;
      renderBettingPanel();
      updateBettingPanelTimer();
      document.getElementById('betting-panel').classList.add('visible');
      document.getElementById('betting-panel-backdrop').classList.add('visible');
      if (!window._bettingPanelTimer) {
        window._bettingPanelTimer = setInterval(updateBettingPanelTimer, 1000);
      }
    };

    window.closeBettingPanel = function() {
      if (bettingPanelOpen) SFX.panelClose();
      bettingPanelOpen = false;
      document.getElementById('betting-panel').classList.remove('visible');
      document.getElementById('betting-panel-backdrop').classList.remove('visible');
      document.getElementById('betting-panel').style.borderColor = '';
      if (window._bettingPanelTimer) {
        clearInterval(window._bettingPanelTimer);
        window._bettingPanelTimer = null;
      }
    };

    window.prevBull = function() {
      SFX.tick();
      panelBullIndex = (panelBullIndex - 1 + NUM_BULLS) % NUM_BULLS;
      renderBettingPanel();
    };

    window.nextBull = function() {
      SFX.tick();
      panelBullIndex = (panelBullIndex + 1) % NUM_BULLS;
      renderBettingPanel();
    };

    window.goToBull = function(idx) {
      SFX.tick();
      panelBullIndex = idx;
      renderBettingPanel();
    };

    function showWarnings() {
      if (!RM.myBet || RM.trackType < 0) return;
      const stats = RM.bullStats[RM.myBet.bullIndex];
      const mults = TRACK_MULTIPLIERS[RM.trackType];
      const trackName = TRACK_TYPES[RM.trackType].name;
      const warnings = [];

      if (mults[5] < -3 && stats[5] >= 7) warnings.push(`HIGH TEMPER (${stats[5]}) ON ${trackName}`);
      if (mults[0] < -2 && stats[0] >= 7) warnings.push(`SPEED (${stats[0]}) PENALIZED ON ${trackName}`);
      if (mults[1] >= 8 && stats[1] <= 3) warnings.push(`LOW STAMINA (${stats[1]}) ON ENDURANCE`);
      if (mults[3] < -2 && stats[3] >= 7) warnings.push(`STRENGTH (${stats[3]}) PENALIZED`);

      const panel = document.getElementById('your-bet-body');
      const bc = bullColors[RM.myBet.bullIndex];
      let html = `<div style="margin-bottom:4px">Bull: <span style="color:${bc.dot};font-weight:700">${bc.name}</span></div>`;
      html += `<div>Amount: <span style="color:var(--secondary)">${RM.myBet.amount.toFixed(2)} MON</span></div>`;
      if (RM.trackType >= 0) {
        html += `<div style="margin-top:4px">Track: ${trackName}</div>`;
      }
      if (warnings.length > 0) {
        html += warnings.map(w => `<div class="yb-warning">${w}</div>`).join('');
      }
      if (RM.phase === 'switching') {
        html += `<button class="switch-btn" onclick="openSwitchMode()">[ SWITCH BET ] (5% FEE)</button>`;
        html += `<div style="color:var(--muted);font-size:8px;margin-top:2px">You keep: ${(RM.myBet.amount * 0.95).toFixed(2)} MON</div>`;
      }
      panel.innerHTML = html;
    }

    function getTotalPoolForBull(idx) {
      return RM.bullPools[idx] || 0;
    }

    function getTotalPool() {
      let total = 0;
      for (let i = 0; i < NUM_BULLS; i++) total += getTotalPoolForBull(i);
      return total;
    }

    function updatePoolDisplay() {
      document.getElementById('pool-display').textContent = `POOL: ${getTotalPool().toFixed(2)} MON`;
    }

    function renderResults() {
      const body = document.getElementById('results-body');
      const winnerIdx = RM.finishOrder[0];
      const wc = bullColors[winnerIdx];

      let html = `<div class="result-winner">> WINNER: <span style="color:${wc.dot}">${wc.name}</span></div>`;

      for (let rank = 0; rank < NUM_BULLS; rank++) {
        const idx = RM.finishOrder[rank];
        const bc = bullColors[idx];
        const isYours = RM.myBet && RM.myBet.bullIndex === idx;
        const medal = rank === 0 ? ' [1ST]' : rank === 1 ? ' [2ND]' : rank === 2 ? ' [3RD]' : '';
        html += `<div class="result-row ${isYours ? 'your-bet' : ''}">
          <span>${String(rank + 1).padStart(2, '0')}. <span style="color:${bc.dot}">${bc.name}</span>${medal}${isYours ? ' <-' : ''}</span>
          <span class="score">score: ${RM.scores[idx]}</span>
        </div>`;
      }

      html += `<div style="margin-top:8px;color:var(--muted);font-size:10px">TRACK: ${TRACK_TYPES[RM.trackType].name} | POOL: ${getTotalPool().toFixed(2)} MON</div>`;

      if (RM.myBet) {
        const myRank = RM.finishOrder.indexOf(RM.myBet.bullIndex);
        const won = myRank === 0;
        if (won) {
          const myPool = getTotalPoolForBull(RM.myBet.bullIndex);
          const payout = (getTotalPool() * 0.9) * (RM.myBet.amount / myPool);
          const profit = payout - RM.myBet.amount;
          html += `<div class="your-result won">> YOU WON! +${profit.toFixed(2)} MON (${payout.toFixed(2)} total)</div>`;
          html += `<button class="claim-btn" onclick="claimWinnings()">[ CLAIM ${payout.toFixed(2)} MON ]</button>`;
        } else {
          html += `<div class="your-result lost">> LOST: -${RM.myBet.amount.toFixed(2)} MON (your bull: #${myRank + 1})</div>`;
        }
      } else {
        html += `<div class="your-result" style="color:var(--muted)">> NO BET PLACED</div>`;
      }

      html += `<div id="next-race-timer">> next race in --:--</div>`;
      body.innerHTML = html;
    }

    // ======== BETTING FUNCTIONS (exposed to onclick) ========
    window.openBetModal = function(bullIndex) {
      if (RM.phase !== 'betting' && RM.phase !== 'switching') return;
      if (RM.myBet) return; // already bet
      if (!RM.walletConnected) { SFX.error(); alert('Connect wallet first'); return; }
      SFX.panelOpen();
      document.getElementById('bet-modal-backdrop').style.display = 'block';
      document.getElementById('bet-modal').style.display = 'block';
      // Start countdown timer in modal
      updateModalCountdown();
      window._modalCountdown = setInterval(updateModalCountdown, 1000);
      document.getElementById('modal-bull-name').textContent = bullColors[bullIndex].name;
      document.getElementById('modal-bull-name').style.color = bullColors[bullIndex].dot;
      const pool = getTotalPoolForBull(bullIndex);
      const total = getTotalPool();
      const odds = pool > 0 ? ((total + 5) / (pool + 5) * 0.9).toFixed(1) : '~9.0';
      document.getElementById('modal-odds').textContent = `Est. return: ~${odds}x`;
      document.getElementById('bet-amount').value = '';
      document.getElementById('bet-amount').focus();
      window._betModalBull = bullIndex;
    };

    window.closeBetModal = function() {
      SFX.panelClose();
      document.getElementById('bet-modal-backdrop').style.display = 'none';
      document.getElementById('bet-modal').style.display = 'none';
      if (window._modalCountdown) { clearInterval(window._modalCountdown); window._modalCountdown = null; }
    };

    window.confirmBet = async function() {
      const amount = parseFloat(document.getElementById('bet-amount').value);
      if (!amount || amount < 0.01 || amount > 100) { SFX.error(); alert('Invalid amount (0.01 - 100 MON)'); return; }
      if (!contractWrite) { SFX.error(); alert('Wallet not connected'); return; }
      try {
        const amountWei = ethers.parseEther(amount.toString());
        const tx = await contractWrite.placeBet(
          RM.raceId,
          window._betModalBull,
          '0x0000000000000000000000000000000000000000',
          amountWei,
          { value: amountWei }
        );
        SFX.confirm();
        closeBetModal();
        await tx.wait();
        RM.myBet = { bullIndex: window._betModalBull, amount };
        renderBullCards();
        if (document.getElementById('betting-panel').classList.contains('visible')) {
          renderBettingPanel();
        }
        updatePoolDisplay();
        // Refresh balance
        if (provider && userAddress) {
          const bal = await provider.getBalance(userAddress);
          RM.walletBalance = parseFloat(ethers.formatEther(bal));
        }
        updateBalanceDisplay();
        document.getElementById('your-bet-panel').classList.add('visible');
        showWarnings();
        if (RM.phase === 'switching') {
          document.getElementById('bet-trigger-btn').textContent = '[ REVIEW / SWITCH ]';
        }
      } catch (err) {
        SFX.error();
        console.error('Bet failed:', err);
        alert('Bet failed: ' + (err.reason || err.message || 'unknown error'));
      }
    };

    window.openSwitchMode = function() {
      if (RM.phase !== 'switching' || !RM.myBet) return;
      SFX.click();
      RM.switchMode = true;
      // Open betting panel so user can browse and pick a new bull
      renderBullCards();
      openBettingPanel();
      // Update your-bet panel to show switch-mode state
      const panel = document.getElementById('your-bet-body');
      const bc = bullColors[RM.myBet.bullIndex];
      panel.innerHTML = `<div style="color:var(--secondary);font-weight:700;margin-bottom:4px">> SWITCH MODE</div>
        <div>Current: <span style="color:${bc.dot}">${bc.name}</span> (${RM.myBet.amount.toFixed(2)} MON)</div>
        <div style="color:var(--muted);font-size:9px;margin-top:2px">Pick a new bull. 5% fee applies.</div>
        <button class="switch-btn" onclick="cancelSwitchMode()" style="margin-top:6px">[ CANCEL ]</button>`;
    };

    window.cancelSwitchMode = function() {
      RM.switchMode = false;
      SFX.click();
      renderBullCards();
      if (document.getElementById('betting-panel').classList.contains('visible')) {
        renderBettingPanel();
      }
      showWarnings();
    };

    window.confirmSwitch = async function(newBullIndex) {
      if (!RM.myBet || !RM.switchMode) return;
      if (newBullIndex === RM.myBet.bullIndex) { SFX.error(); return; }
      if (!contractWrite) { SFX.error(); alert('Wallet not connected'); return; }
      try {
        const tx = await contractWrite.switchBet(RM.raceId, newBullIndex);
        SFX.confirm();
        closeBettingPanel();
        await tx.wait();
        const oldAmount = RM.myBet.amount;
        const remaining = oldAmount * 0.95;
        RM.myBet = { bullIndex: newBullIndex, amount: remaining };
        RM.switchMode = false;
        renderBullCards();
        updatePoolDisplay();
        if (provider && userAddress) {
          const bal = await provider.getBalance(userAddress);
          RM.walletBalance = parseFloat(ethers.formatEther(bal));
        }
        updateBalanceDisplay();
        showWarnings();
      } catch (err) {
        SFX.error();
        console.error('Switch failed:', err);
        alert('Switch failed: ' + (err.reason || err.message || 'unknown error'));
      }
    };

    window.connectWallet = async function() {
      SFX.click();
      if (RM.walletConnected) {
        // Open account view — user can disconnect from there
        appKitModal.open({ view: 'Account' });
      } else {
        // Clear any stale cached session before showing wallet selection
        try { await appKitModal.disconnect(); } catch(e) {}
        appKitModal.open({ view: 'Connect' });
      }
    };

    window.claimWinnings = async function() {
      if (!contractWrite || !RM.myBet) return;
      try {
        const tx = await contractWrite.claimWinnings(RM.raceId);
        SFX.chaChing();
        await tx.wait();
        if (provider && userAddress) {
          const bal = await provider.getBalance(userAddress);
          RM.walletBalance = parseFloat(ethers.formatEther(bal));
          const short = userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
          document.getElementById('wallet-btn').textContent = `${short} | ${RM.walletBalance.toFixed(1)} MON`;
        }
        updateClaimBanner();
        updateBalanceDisplay();
      } catch (err) {
        SFX.error();
        console.error('Claim failed:', err);
        alert('Claim failed: ' + (err.reason || err.message || 'unknown error'));
      }
    };

    window.updateModalCountdown = function() {
      const remaining = getPhaseTimeRemaining();
      const m = Math.floor(remaining / 60);
      const s = Math.floor(remaining % 60);
      const el = document.getElementById('modal-countdown');
      const phase = RM.phase === 'switching' ? 'switching closes' : 'betting closes';
      if (el) el.textContent = `> ${phase} in ${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    };

    function updateClaimBanner() {
      const banner = document.getElementById('claim-banner');
      // Show claim banner if user won and hasn't claimed
      if (RM.myBet && RM.phase === 'results' && RM.walletConnected && RM.finishOrder[0] === RM.myBet.bullIndex) {
        const myPool = getTotalPoolForBull(RM.myBet.bullIndex);
        const payout = (getTotalPool() * 0.9) * (RM.myBet.amount / myPool);
        banner.textContent = `> UNCLAIMED: ${payout.toFixed(2)} MON  [ CLAIM ]`;
        banner.classList.add('visible');
      } else {
        banner.classList.remove('visible');
      }
    }

    function updateBalanceDisplay() {
      const el = document.getElementById('bal-display');
      if (RM.walletConnected) {
        el.textContent = `BAL: ${RM.walletBalance.toFixed(1)} MON`;
        el.classList.add('active');
      } else {
        el.textContent = 'BAL: --.-- MON';
        el.classList.remove('active');
      }
    }

    // ======== TRACK BANNER ========
    function showTrackBanner() {
      if (RM.trackType < 0) return;
      const track = TRACK_TYPES[RM.trackType];
      const mults = TRACK_MULTIPLIERS[RM.trackType];
      let html = `<div class="tb-name">> ${track.name}</div>`;
      html += `<div class="tb-desc">${track.desc} | ${track.dist}M</div>`;
      for (let s = 0; s < 6; s++) {
        const m = mults[s];
        let cls = 'tb-neutral';
        let sign = '';
        if (s === 5) {
          // Temper: positive = high favored, negative = low favored
          if (m > 0) { cls = 'tb-boost'; sign = 'HIGH+'; }
          else if (m < -3) { cls = 'tb-penalty'; sign = 'LOW+'; }
          else if (m < 0) { cls = 'tb-penalty'; sign = 'LOW+'; }
          else { sign = '---'; }
        } else {
          if (m >= 5) { cls = 'tb-boost'; sign = '+++'; }
          else if (m >= 2) { cls = 'tb-boost'; sign = '++'; }
          else if (m > 0) { cls = 'tb-boost'; sign = '+'; }
          else if (m <= -3) { cls = 'tb-penalty'; sign = '---'; }
          else if (m < 0) { cls = 'tb-penalty'; sign = '--'; }
          else { sign = '.'; }
        }
        html += `<div class="tb-stat"><span>${STAT_FULL[s]}</span><span class="${cls}">${sign}</span></div>`;
      }
      document.getElementById('track-banner-body').innerHTML = html;
      document.getElementById('track-banner').classList.add('visible');
    }
    function hideTrackBanner() {
      document.getElementById('track-banner').classList.remove('visible');
    }

    // ======== BULL 3D CLICK → STAT POPUP ========
    const raycaster = new THREE.Raycaster();
    const _mouse = new THREE.Vector2();

    function showBullStatPopup(bullIndex) {
      const stats = RM.bullStats[bullIndex];
      if (!stats) return;
      SFX.click();
      const bc = bullColors[bullIndex];
      const popup = document.getElementById('bull-stat-popup');
      const nameEl = document.getElementById('popup-bull-name');
      const bodyEl = document.getElementById('popup-body');

      nameEl.textContent = bc.name;
      nameEl.style.color = bc.dot;

      let html = '';
      for (let s = 0; s < 6; s++) {
        const val = stats[s];
        const filled = '|'.repeat(val);
        const empty = '\u00B7'.repeat(10 - val);
        const color = s === 5 ? (val >= 7 ? 'var(--error)' : val <= 3 ? 'var(--primary)' : bc.dot) : bc.dot;
        const warn = s === 5 && val >= 7 ? ' \u26A1' : '';
        html += `<div class="popup-stat">
          <span class="popup-stat-label">${STAT_FULL[s]}</span>
          <span class="popup-stat-bar" style="color:${color}">${filled}<span style="color:#2a6b2a">${empty}</span></span>
          <span class="popup-stat-val" style="color:${color}">${val}${warn}</span>
        </div>`;
      }

      const pool = getTotalPoolForBull(bullIndex);
      const totalPool = getTotalPool();
      const odds = pool > 0 ? (totalPool / pool * 0.9).toFixed(1) : '--';
      html += `<div class="popup-pool">
        <span>POOL: ${pool.toFixed(1)} MON</span>
        <span style="color:var(--secondary)">${odds}x</span>
      </div>`;

      if (RM.switchMode && RM.myBet && RM.myBet.bullIndex !== bullIndex) {
        html += `<button class="popup-bet-btn" style="border-color:var(--secondary);color:var(--secondary)" onclick="hideBullStatPopup(); confirmSwitch(${bullIndex})">[ SWITCH TO ${bc.name.toUpperCase()} ]</button>`;
      } else if ((RM.phase === 'betting' || RM.phase === 'switching') && !RM.myBet && RM.walletConnected) {
        html += `<button class="popup-bet-btn" onclick="hideBullStatPopup(); openBetModal(${bullIndex})">[ BET ON ${bc.name.toUpperCase()} ]</button>`;
      }

      bodyEl.innerHTML = html;
      popup.classList.add('visible');
    }

    window.hideBullStatPopup = function() {
      SFX.panelClose();
      document.getElementById('bull-stat-popup').classList.remove('visible');
    };

    renderer.domElement.addEventListener('click', (e) => {
      if (bulls.length === 0) return;
      _mouse.x = (e.clientX / innerWidth) * 2 - 1;
      _mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(_mouse, camera);
      for (let i = 0; i < bulls.length; i++) {
        const intersects = raycaster.intersectObject(bulls[i].group, true);
        if (intersects.length > 0) {
          showBullStatPopup(i);
          return;
        }
      }
    });

    // ======== AUDIO ========
    let audioCtx = null;
    function ensureAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      return audioCtx;
    }
    function playBeep(freq, duration, volume = 0.3) {
      const ctx = ensureAudio();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'square'; osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
      osc.connect(gain); gain.connect(ctx.destination);
      osc.start(ctx.currentTime); osc.stop(ctx.currentTime + duration);
    }

    // --- Terminal Sound Library (synthesized retro/CRT aesthetic) ---
    // Helper: create noise buffer
    function _noiseBuf(ctx, dur) {
      const sz = ctx.sampleRate * dur;
      const buf = ctx.createBuffer(1, sz, ctx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i = 0; i < sz; i++) d[i] = Math.random() * 2 - 1;
      return buf;
    }

    const SFX = {
      // Typewriter key — noise burst through bandpass filter (mechanical click)
      typeKey() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.02);
        const bp = ctx.createBiquadFilter();
        bp.type = 'bandpass'; bp.frequency.value = 3000 + Math.random() * 1500; bp.Q.value = 2;
        const g = ctx.createGain();
        g.gain.setValueAtTime(0.08, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.018);
        noise.connect(bp); bp.connect(g); g.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.02);
      },

      // UI tick — carousel nav, indicator dots
      tick() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // Noise click attack
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.015);
        const hp = ctx.createBiquadFilter();
        hp.type = 'highpass'; hp.frequency.value = 4000;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.1, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.012);
        noise.connect(hp); hp.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.015);
        // Tonal body
        const osc = ctx.createOscillator(); const g = ctx.createGain();
        osc.type = 'square'; osc.frequency.value = 1400 + Math.random() * 200;
        g.gain.setValueAtTime(0.06, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.025);
        osc.connect(g); g.connect(ctx.destination);
        osc.start(t); osc.stop(t + 0.03);
      },

      // UI click — buttons, popup open
      click() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // Noise transient
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.03);
        const bp = ctx.createBiquadFilter();
        bp.type = 'bandpass'; bp.frequency.value = 2500; bp.Q.value = 1.5;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.12, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.025);
        noise.connect(bp); bp.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.03);
        // Pitch-drop tone
        const osc = ctx.createOscillator(); const g = ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(900, t);
        osc.frequency.exponentialRampToValueAtTime(500, t + 0.06);
        g.gain.setValueAtTime(0.1, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.07);
        osc.connect(g); g.connect(ctx.destination);
        osc.start(t); osc.stop(t + 0.07);
      },

      // Panel open — rising filtered sweep + whoosh noise
      panelOpen() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // Whoosh noise
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.2);
        const lp = ctx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.setValueAtTime(200, t);
        lp.frequency.exponentialRampToValueAtTime(6000, t + 0.15);
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.06, t);
        ng.gain.setValueAtTime(0.08, t + 0.05);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
        noise.connect(lp); lp.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.2);
        // Rising tone
        const osc = ctx.createOscillator(); const g = ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(1000, t + 0.12);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass'; f.frequency.value = 3000; f.Q.value = 3;
        g.gain.setValueAtTime(0.06, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        osc.connect(f); f.connect(g); g.connect(ctx.destination);
        osc.start(t); osc.stop(t + 0.15);
      },

      // Panel close — falling filtered sweep + whoosh
      panelClose() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // Whoosh noise
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.2);
        const lp = ctx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.setValueAtTime(6000, t);
        lp.frequency.exponentialRampToValueAtTime(200, t + 0.15);
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.08, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
        noise.connect(lp); lp.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.2);
        // Falling tone
        const osc = ctx.createOscillator(); const g = ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(1000, t);
        osc.frequency.exponentialRampToValueAtTime(150, t + 0.12);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass'; f.frequency.value = 3000; f.Q.value = 3;
        g.gain.setValueAtTime(0.06, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        osc.connect(f); f.connect(g); g.connect(ctx.destination);
        osc.start(t); osc.stop(t + 0.15);
      },

      // Confirm — ascending 3-note chime with harmonics
      confirm() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        [660, 880, 1100].forEach((f, i) => {
          const osc = ctx.createOscillator(); const g = ctx.createGain();
          osc.type = 'square'; osc.frequency.value = f;
          g.gain.setValueAtTime(0.12, t + i * 0.08);
          g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.08 + 0.18);
          osc.connect(g); g.connect(ctx.destination);
          osc.start(t + i * 0.08); osc.stop(t + i * 0.08 + 0.18);
          // Octave harmonic
          const osc2 = ctx.createOscillator(); const g2 = ctx.createGain();
          osc2.type = 'sine'; osc2.frequency.value = f * 2;
          g2.gain.setValueAtTime(0.04, t + i * 0.08);
          g2.gain.exponentialRampToValueAtTime(0.001, t + i * 0.08 + 0.12);
          osc2.connect(g2); g2.connect(ctx.destination);
          osc2.start(t + i * 0.08); osc2.stop(t + i * 0.08 + 0.12);
        });
      },

      // Error — harsh descending buzz with distortion
      error() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // Main buzz
        const osc = ctx.createOscillator(); const g = ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(180, t);
        osc.frequency.exponentialRampToValueAtTime(80, t + 0.2);
        g.gain.setValueAtTime(0.18, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g); g.connect(ctx.destination);
        osc.start(t); osc.stop(t + 0.3);
        // Sub buzz
        const osc2 = ctx.createOscillator(); const g2 = ctx.createGain();
        osc2.type = 'square'; osc2.frequency.value = 60;
        g2.gain.setValueAtTime(0.1, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
        osc2.connect(g2); g2.connect(ctx.destination);
        osc2.start(t); osc2.stop(t + 0.25);
        // Noise crackle
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.1);
        const bp = ctx.createBiquadFilter();
        bp.type = 'bandpass'; bp.frequency.value = 800; bp.Q.value = 1;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.08, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
        noise.connect(bp); bp.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.1);
      },

      // Phase transition — dramatic filtered sweep + impact hit + noise wash
      phaseChange() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // Rising sweep
        const osc1 = ctx.createOscillator(); const g1 = ctx.createGain();
        osc1.type = 'sawtooth';
        osc1.frequency.setValueAtTime(80, t);
        osc1.frequency.exponentialRampToValueAtTime(1500, t + 0.2);
        const f1 = ctx.createBiquadFilter();
        f1.type = 'lowpass'; f1.frequency.setValueAtTime(500, t);
        f1.frequency.exponentialRampToValueAtTime(8000, t + 0.2);
        g1.gain.setValueAtTime(0.1, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc1.connect(f1); f1.connect(g1); g1.connect(ctx.destination);
        osc1.start(t); osc1.stop(t + 0.3);
        // Impact hit
        const osc2 = ctx.createOscillator(); const g2 = ctx.createGain();
        osc2.type = 'square'; osc2.frequency.value = 440;
        g2.gain.setValueAtTime(0.2, t + 0.18);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.45);
        osc2.connect(g2); g2.connect(ctx.destination);
        osc2.start(t + 0.18); osc2.stop(t + 0.45);
        // Noise wash
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.3);
        const lp = ctx.createBiquadFilter();
        lp.type = 'lowpass'; lp.frequency.value = 3000;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.001, t);
        ng.gain.linearRampToValueAtTime(0.1, t + 0.18);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
        noise.connect(lp); lp.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.4);
      },

      // Cha-ching — cash register: metallic ring + ascending sparkle
      chaChing() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // Metallic ring (detuned oscillators)
        [2637, 2793].forEach((f) => {
          const osc = ctx.createOscillator(); const g = ctx.createGain();
          osc.type = 'sine'; osc.frequency.value = f;
          g.gain.setValueAtTime(0.1, t);
          g.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
          osc.connect(g); g.connect(ctx.destination);
          osc.start(t); osc.stop(t + 0.4);
        });
        // Ascending sparkle
        [1200, 1600, 2000, 2600].forEach((f, i) => {
          const osc = ctx.createOscillator(); const g = ctx.createGain();
          osc.type = 'square'; osc.frequency.value = f;
          g.gain.setValueAtTime(0.08, t + 0.05 + i * 0.06);
          g.gain.exponentialRampToValueAtTime(0.001, t + 0.05 + i * 0.06 + 0.1);
          osc.connect(g); g.connect(ctx.destination);
          osc.start(t + 0.05 + i * 0.06); osc.stop(t + 0.05 + i * 0.06 + 0.1);
        });
        // Noise click transient
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.03);
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.15, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
        noise.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.03);
      },

      // Wallet connect — modem handshake: carrier tones + data blips + noise
      walletConnect() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // Carrier tone
        const carrier = ctx.createOscillator(); const cg = ctx.createGain();
        carrier.type = 'sine'; carrier.frequency.value = 1200;
        cg.gain.setValueAtTime(0.06, t);
        cg.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
        carrier.connect(cg); cg.connect(ctx.destination);
        carrier.start(t); carrier.stop(t + 0.4);
        // Data blips
        [2400, 1800, 2400, 1200, 2400, 1800, 1200].forEach((f, i) => {
          const osc = ctx.createOscillator(); const g = ctx.createGain();
          osc.type = 'square'; osc.frequency.value = f;
          const st = t + 0.04 + i * 0.04;
          g.gain.setValueAtTime(0.06, st);
          g.gain.exponentialRampToValueAtTime(0.001, st + 0.03);
          osc.connect(g); g.connect(ctx.destination);
          osc.start(st); osc.stop(st + 0.035);
        });
        // Static noise
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.4);
        const bp = ctx.createBiquadFilter();
        bp.type = 'bandpass'; bp.frequency.value = 2000; bp.Q.value = 0.5;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.03, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
        noise.connect(bp); bp.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.4);
      },

      // Race start horn — air horn: noise burst + layered sustained tones
      raceHorn() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // Initial noise burst
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.2);
        const bp = ctx.createBiquadFilter();
        bp.type = 'bandpass'; bp.frequency.value = 1000; bp.Q.value = 1;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.2, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        noise.connect(bp); bp.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.2);
        // Layered horn tones
        [220, 330, 440].forEach((f, i) => {
          const osc = ctx.createOscillator(); const g = ctx.createGain();
          osc.type = i === 0 ? 'sawtooth' : 'square';
          osc.frequency.value = f;
          g.gain.setValueAtTime(i === 0 ? 0.12 : 0.06, t + 0.05);
          g.gain.setValueAtTime(i === 0 ? 0.12 : 0.06, t + 0.4);
          g.gain.exponentialRampToValueAtTime(0.001, t + 0.7);
          osc.connect(g); g.connect(ctx.destination);
          osc.start(t + 0.05); osc.stop(t + 0.7);
        });
      },

      // Bull finish — triumphant arpeggio (C-E-G-C) with shimmer
      bullFinish() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        [523, 659, 784, 1047].forEach((f, i) => {
          const osc = ctx.createOscillator(); const g = ctx.createGain();
          osc.type = 'square'; osc.frequency.value = f;
          g.gain.setValueAtTime(0.1, t + i * 0.08);
          g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.08 + 0.2);
          osc.connect(g); g.connect(ctx.destination);
          osc.start(t + i * 0.08); osc.stop(t + i * 0.08 + 0.2);
          // Shimmer harmonic
          const s = ctx.createOscillator(); const sg = ctx.createGain();
          s.type = 'sine'; s.frequency.value = f * 2;
          sg.gain.setValueAtTime(0.03, t + i * 0.08);
          sg.gain.exponentialRampToValueAtTime(0.001, t + i * 0.08 + 0.15);
          s.connect(sg); sg.connect(ctx.destination);
          s.start(t + i * 0.08); s.stop(t + i * 0.08 + 0.15);
        });
      },

      // Boot sequence — CRT power-on + POST beeps + modem init
      bootUp() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // CRT power-on hum (rising sine)
        const hum = ctx.createOscillator(); const hg = ctx.createGain();
        hum.type = 'sine';
        hum.frequency.setValueAtTime(40, t);
        hum.frequency.exponentialRampToValueAtTime(60, t + 0.5);
        hg.gain.setValueAtTime(0.001, t);
        hg.gain.linearRampToValueAtTime(0.08, t + 0.3);
        hg.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
        hum.connect(hg); hg.connect(ctx.destination);
        hum.start(t); hum.stop(t + 0.6);
        // CRT static crackle
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.4);
        const lp = ctx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.setValueAtTime(200, t);
        lp.frequency.exponentialRampToValueAtTime(8000, t + 0.2);
        lp.frequency.exponentialRampToValueAtTime(1000, t + 0.4);
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.001, t);
        ng.gain.linearRampToValueAtTime(0.12, t + 0.15);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
        noise.connect(lp); lp.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.4);
        // POST beeps (ascending)
        [800, 1000, 1200].forEach((f, i) => {
          const osc = ctx.createOscillator(); const g = ctx.createGain();
          osc.type = 'square'; osc.frequency.value = f;
          const bt = t + 0.4 + i * 0.12;
          g.gain.setValueAtTime(0.1, bt);
          g.gain.exponentialRampToValueAtTime(0.001, bt + 0.08);
          osc.connect(g); g.connect(ctx.destination);
          osc.start(bt); osc.stop(bt + 0.08);
        });
      },

      // LFG announcement — big dramatic chord + sweep
      lfg() {
        const ctx = ensureAudio(); const t = ctx.currentTime;
        // Noise impact
        const noise = ctx.createBufferSource();
        noise.buffer = _noiseBuf(ctx, 0.15);
        const bp = ctx.createBiquadFilter();
        bp.type = 'bandpass'; bp.frequency.value = 1500; bp.Q.value = 0.8;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.2, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
        noise.connect(bp); bp.connect(ng); ng.connect(ctx.destination);
        noise.start(t); noise.stop(t + 0.15);
        // Power chord (C5-G5-C6)
        [523, 784, 1047].forEach((f) => {
          const osc = ctx.createOscillator(); const g = ctx.createGain();
          osc.type = 'sawtooth'; osc.frequency.value = f;
          const fl = ctx.createBiquadFilter();
          fl.type = 'lowpass'; fl.frequency.value = 4000;
          g.gain.setValueAtTime(0.1, t + 0.02);
          g.gain.setValueAtTime(0.1, t + 0.3);
          g.gain.exponentialRampToValueAtTime(0.001, t + 0.8);
          osc.connect(fl); fl.connect(g); g.connect(ctx.destination);
          osc.start(t + 0.02); osc.stop(t + 0.8);
        });
        // Rising sweep underneath
        const sweep = ctx.createOscillator(); const sg = ctx.createGain();
        sweep.type = 'sawtooth';
        sweep.frequency.setValueAtTime(100, t);
        sweep.frequency.exponentialRampToValueAtTime(2000, t + 0.3);
        const sf = ctx.createBiquadFilter();
        sf.type = 'lowpass'; sf.frequency.value = 3000;
        sg.gain.setValueAtTime(0.06, t);
        sg.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
        sweep.connect(sf); sf.connect(sg); sg.connect(ctx.destination);
        sweep.start(t); sweep.stop(t + 0.35);
      },
    };

    // ======== PHASE MANAGEMENT ========
    function setPhase(phase) {
      RM.phase = phase;
      RM.phaseStart = clock.getElapsedTime();
      RM.switchMode = false;
      const pd = document.getElementById('phase-display');
      const bc = document.getElementById('bull-cards');
      const rp = document.getElementById('results-panel');
      const tr = document.getElementById('track-reveal');
      const ybp = document.getElementById('your-bet-panel');
      const pi = document.getElementById('phase-info');
      const trigBtn = document.getElementById('bet-trigger-btn');
      const phaseInd = document.getElementById('phase-indicator');

      // Update title bar phase indicator
      phaseInd.className = '';
      const phaseLabels = { waiting: 'WAITING', betting: 'BETTING', revealing: 'REVEAL', switching: 'SWITCHING', racing: 'RACING', results: 'CLOSED' };
      phaseInd.textContent = phaseLabels[phase] || phase.toUpperCase();
      phaseInd.classList.add(phase === 'results' || phase === 'revealing' ? 'closed' : phase);

      // Reset visibility
      pd.className = ''; pd.style.display = 'block';
      bc.classList.remove('visible');
      rp.classList.remove('visible');
      tr.classList.remove('visible');
      trigBtn.classList.remove('visible');
      closeBettingPanel();
      hideTrackBanner();

      switch (phase) {
        case 'waiting':
          SFX.phaseChange();
          typeText(pd, '> generating_bulls');
          pi.innerHTML = '<span class="phase-badge" style="background:var(--muted);color:#ccc">WAITING</span>';
          document.getElementById('track-info').textContent = '> TRACK: --- | 8 BULLS';
          ybp.classList.remove('visible');
          document.getElementById('winner').style.display = 'none';
          // Generate data from on-chain
          const live = getLiveState();
          RM.raceId = live.raceId;
          RM.liveRaceId = live.raceId;
          liveRaceDataLoaded = false;
          generateRaceData();
          document.querySelector('#title-bar .title-text').textContent = `> MOONAD // LIVE RACE #${RM.raceId}`;
          break;

        case 'betting':
          SFX.phaseChange();
          if (!RM.seeded) {
            typeText(pd, '> AWAITING VRF SEED...', 40);
          } else {
            typeText(pd, '> PLACE YOUR BETS', 40);
            setTimeout(() => { pd.classList.add('hidden'); }, 2500);
          }
          pi.innerHTML = '<span class="phase-badge betting">BETTING</span>';
          trigBtn.textContent = '[ PLACE YOUR BETS ]';
          trigBtn.classList.add('visible');
          renderBullCards();
          updatePoolDisplay();
          updateSeedButton();
          // Start bulls walking in
          if (loadedModel && RM.seeded) spawnBulls();
          break;

        case 'revealing': {
          pd.style.display = 'none';
          ybp.classList.remove('visible');
          // Glitch transition before track reveal
          const crt = document.getElementById('crt-overlay');
          crt.classList.add('glitch-intense');
          tr.classList.add('visible');
          const trackNameEl = document.getElementById('track-reveal-name');
          const trackSubEl = document.getElementById('track-reveal-sub');
          trackNameEl.style.opacity = '0';
          trackSubEl.style.opacity = '0';
          playBeep(660, 0.3, 0.25);
          setTimeout(() => {
            crt.classList.remove('glitch-intense');
            trackNameEl.textContent = `> ${TRACK_TYPES[RM.trackType].name}`;
            trackNameEl.style.opacity = '1';
            trackSubEl.textContent = TRACK_TYPES[RM.trackType].desc;
            trackSubEl.style.opacity = '1';
            playBeep(880, 0.2, 0.3);
          }, 1500);
          document.getElementById('track-info').textContent = `> TRACK: ${TRACK_TYPES[RM.trackType].name} | ${TRACK_TYPES[RM.trackType].dist}M`;
          break;
        }

        case 'switching':
          SFX.phaseChange();
          tr.classList.remove('visible');
          typeText(pd, '> SWITCH OR HOLD', 40);
          setTimeout(() => { pd.classList.add('hidden'); }, 2500);
          pi.innerHTML = '<span class="phase-badge switching">SWITCHING</span>';
          trigBtn.textContent = RM.myBet ? '[ REVIEW / SWITCH ]' : '[ PLACE YOUR BETS ]';
          trigBtn.classList.add('visible');
          showTrackBanner();
          renderBullCards();
          if (RM.myBet) {
            ybp.classList.add('visible');
            showWarnings();
          }
          break;

        case 'racing':
          SFX.raceHorn();
          pd.style.display = 'none';
          ybp.classList.remove('visible');
          pi.innerHTML = '<span class="phase-badge racing">RACING</span>';
          // Reset camera to chase for race start
          camMode = 'chase'; controls.enabled = false; cameraReady = false;
          updateCamButtons();
          hideBullStatPopup();
          // Compute results and start race
          computeRaceResults();
          startRace();
          break;

        case 'results':
          SFX.phaseChange();
          pd.style.display = 'none';
          pi.innerHTML = '';
          renderResults();
          rp.classList.add('visible');
          updateClaimBanner();
          updateBalanceDisplay();
          break;
      }
    }

    function getPhaseTimeRemaining() {
      const live = getLiveState();
      switch (RM.phase) {
        case 'waiting':
          // Brief local loading phase (6s max)
          return Math.max(0, 6 - (clock.getElapsedTime() - RM.phaseStart));
        case 'betting':
          // Counts down to end of contract BETTING phase
          return Math.max(0, liveBettingDuration - live.elapsed);
        case 'revealing':
          // Brief local track-reveal animation (3s)
          return Math.max(0, 3 - (clock.getElapsedTime() - RM.phaseStart));
        case 'switching':
          // Counts down to end of contract SWITCHING phase
          return Math.max(0, liveSwitchingEnd - live.elapsed);
        case 'racing':
          return 999; // Self-terminating via animation completion
        case 'results':
          // Counts down to end of cycle (next race starts)
          return Math.max(0, liveCycleDuration - live.elapsed);
        default:
          return 999;
      }
    }

    function updatePhaseTimer() {
      const remaining = getPhaseTimeRemaining();
      if (RM.phase === 'waiting' || RM.phase === 'betting' || RM.phase === 'switching' || RM.phase === 'results') {
        const m = Math.floor(remaining / 60);
        const s = Math.floor(remaining % 60);
        const timeStr = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        document.getElementById('clock-display').textContent = timeStr;
        // Also update the next-race-timer in results panel
        if (RM.phase === 'results') {
          const nrt = document.getElementById('next-race-timer');
          if (nrt) nrt.textContent = `> next race in ${timeStr}`;
        }
      }

      // Auto-advance phases
      if (remaining <= 0) {
        switch (RM.phase) {
          case 'waiting':
            if (!liveRaceDataLoaded) return;
            setPhase('betting');
            break;
          case 'betting': setPhase('revealing'); break;
          case 'revealing': setPhase('switching'); break;
          case 'switching': setPhase('racing'); break;
          case 'results': cleanupRace(); setPhase('waiting'); break;
        }
      }
    }

    // ======== BULL SPAWNING ========
    function spawnBulls() {
      cleanupBulls();
      raceStarted = false;
      raceOver = false;
      nextRank = 1;
      countdownStarted = false;
      // Reset camera to start line
      camTrackX = 0; lastCamTrackX = 0;
      cameraReady = false;
      camera.position.set(-12, 6, 12);
      controls.target.set(0, 1.5, 0);
      camera.lookAt(controls.target);
      gridHelper.position.x = 0;
      trackGrid.position.x = 0;
      speedLines.position.x = 0;
      sun.position.x = 10;
      camMode = 'chase'; controls.enabled = false;
      updateCamButtons();

      const fbx = loadedModel;
      const animations = loadedAnimations;

      const runClip = stripRootMotion(animations.find(c => c.name.includes('Run_F_RM')) || animations[0]);
      const idleClip = stripRootMotion(animations.find(c => c.name.includes('Idle_1')) || animations[0]);
      const trotClip = stripRootMotion(animations.find(c => c.name.includes('Trot_F_RM')) || runClip);
      const walkClip = stripRootMotion(animations.find(c => c.name.includes('Walk_F_RM')) || animations.find(c => c.name.includes('Walk')) || trotClip);
      const lieStartClip = stripRootMotion(animations.find(c => c.name.includes('Lie_start')) || idleClip);
      const lieLoopClip = stripRootMotion(animations.find(c => c.name.includes('Lie_loop1')) || animations.find(c => c.name.includes('Lie_loop')) || idleClip);
      const attackRunClip = stripRootMotion(animations.find(c => c.name.includes('Attack_Run_RM')) || runClip);
      const idleClips = animations.filter(c => /Idle_\d/.test(c.name)).map(c => stripRootMotion(c));
      if (idleClips.length === 0) idleClips.push(idleClip);

      for (let i = 0; i < NUM_BULLS; i++) {
        const laneZ = (i - NUM_BULLS / 2 + 0.5) * LANE_WIDTH;
        const laneGroup = new THREE.Group();
        laneGroup.position.z = laneZ;

        const bullClone = SkeletonUtils.clone(fbx);
        bullClone.scale.setScalar(modelScale);
        bullClone.rotation.y = bestRotY;

        // Wireframe with bull color, strength affects scale slightly
        const strengthScale = RM.bullStats[i] ? 1 + (RM.bullStats[i][3] - 5) * 0.01 : 1;
        bullClone.scale.multiplyScalar(strengthScale);

        bullClone.traverse(child => {
          if (child.isMesh) {
            child.material = new THREE.MeshBasicMaterial({
              color: bullColors[i].wire, wireframe: true, transparent: true, opacity: 0.85,
            });
          }
        });

        laneGroup.add(bullClone);
        laneGroup.updateMatrixWorld(true);

        const bullBox = new THREE.Box3().setFromObject(laneGroup);
        const bullCenter = bullBox.getCenter(new THREE.Vector3());
        bullClone.position.y -= bullBox.min.y;
        bullClone.position.x -= bullCenter.x;
        bullClone.position.z -= (bullCenter.z - laneZ);

        scene.add(laneGroup);

        const mixer = new THREE.AnimationMixer(bullClone);
        const idleAction = mixer.clipAction(idleClip);
        const runAction = mixer.clipAction(runClip);
        const walkAction = mixer.clipAction(walkClip);
        const lieStartAction = mixer.clipAction(lieStartClip);
        const lieLoopAction = mixer.clipAction(lieLoopClip);
        const attackRunAction = mixer.clipAction(attackRunClip);
        attackRunAction.setLoop(THREE.LoopOnce); attackRunAction.clampWhenFinished = true;
        const restIdleClip = idleClips[Math.floor(Math.random() * idleClips.length)];
        const restIdleAction = mixer.clipAction(restIdleClip);
        lieStartAction.setLoop(THREE.LoopOnce); lieStartAction.clampWhenFinished = true;

        walkAction.play();
        mixer.setTime(Math.random() * walkClip.duration);

        mixer.addEventListener('finished', (e) => {
          if (e.action === lieStartAction) { lieStartAction.fadeOut(0.5); lieLoopAction.reset().fadeIn(0.5).play(); }
          if (e.action === attackRunAction) {
            attackRunAction.fadeOut(0.5); walkAction.reset().fadeIn(0.5).play();
            const b = bulls.find(b => b.mixer === mixer);
            if (b) b.isWalking = true;
          }
        });

        const walkDuration = 3 + Math.random() * 4;
        const idleDuration = 3 + Math.random() * 3;

        bulls.push({
          group: laneGroup, clone: bullClone, mixer,
          idleAction, runAction, walkAction, lieStartAction, lieLoopAction, attackRunAction, restIdleAction,
          speed: 12, // will be set from scores later
          phase: Math.random() * Math.PI * 2,
          temperValue: RM.bullStats[i] ? RM.bullStats[i][5] : 5,
          flickerPhase: Math.random() * Math.PI * 2,
          laneZ,
          racePos: -20 - Math.random() * 10,
          startTarget: -3,
          walkSpeed: 2.0 + Math.random() * 0.8,
          arrived: false,
          name: bullColors[i].name,
          color: bullColors[i].dot,
          finished: false, finishRank: 0, finishTime: 0,
          isRunning: false, isWalking: false, isIdling: false, isLying: false,
          postDecel: 2,
          postWalkEnd: 2 + walkDuration,
          postIdleEnd: 2 + walkDuration + idleDuration,
        });
      }
    }

    // Create floating rank label sprite (1ST / 2ND / 3RD)
    const rankLabels = [];
    function createRankSprite(rank, color) {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 128;
      const ctx2d = canvas.getContext('2d');
      const text = rank === 1 ? '1ST' : rank === 2 ? '2ND' : '3RD';
      const bgColor = rank === 1 ? '#ffb000' : rank === 2 ? '#c0c0c0' : '#cd7f32';
      // Background box
      ctx2d.fillStyle = bgColor;
      ctx2d.roundRect ? ctx2d.roundRect(16, 8, 224, 112, 4) : ctx2d.fillRect(16, 8, 224, 112);
      ctx2d.fill();
      // Text
      ctx2d.fillStyle = '#0a0a0a';
      ctx2d.font = 'bold 80px monospace';
      ctx2d.textAlign = 'center';
      ctx2d.textBaseline = 'middle';
      ctx2d.fillText(text, 128, 64);
      // Border
      ctx2d.strokeStyle = '#0a0a0a';
      ctx2d.lineWidth = 4;
      ctx2d.strokeRect(16, 8, 224, 112);

      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(2.0, 1.0, 1);
      sprite.renderOrder = 999;
      return sprite;
    }

    function cleanupBulls() {
      for (const bull of bulls) {
        scene.remove(bull.group);
        bull.mixer.stopAllAction();
      }
      bulls = [];
      // Remove rank label sprites
      for (const lbl of rankLabels) { scene.remove(lbl); lbl.material.map.dispose(); lbl.material.dispose(); }
      rankLabels.length = 0;
    }

    function cleanupRace() {
      cleanupBulls();
      raceStarted = false;
      raceOver = false;
      document.getElementById('results-panel').classList.remove('visible');
      document.getElementById('winner').style.display = 'none';
    }

    function startRace() {
      // Set speeds from computed scores
      const minScore = Math.min(...RM.scores);
      const maxScore = Math.max(...RM.scores);
      const range = Math.max(1, maxScore - minScore);
      for (let i = 0; i < bulls.length; i++) {
        const normalized = (RM.scores[i] - minScore) / range;
        bulls[i].speed = 10 + normalized * 5;
      }
      // Trigger countdown
      startCountdown();
    }

    function startCountdown() {
      const cdEl = document.getElementById('countdown');
      cdEl.style.display = 'block';
      let count = 3;
      cdEl.textContent = `> ${count}_`;
      playBeep(440, 0.15, 0.25);
      const interval = setInterval(() => {
        count--;
        if (count > 0) {
          cdEl.textContent = `> ${count}_`;
          playBeep(440, 0.15, 0.25);
        } else if (count === 0) {
          cdEl.textContent = '> RUN_';
          cdEl.className = 'go';
          playBeep(880, 0.4, 0.35);
          raceStarted = true;
          raceStartTime = clock.getElapsedTime();
        } else {
          cdEl.style.display = 'none';
          cdEl.className = '';
          clearInterval(interval);
        }
      }, 1000);
    }

    // ======== MODEL LOADING ========
    const loader = new GLTFLoader();
    loader.load('bull.glb', (gltf) => {
      loadedModel = gltf.scene;
      loadedAnimations = gltf.animations;

      console.log(`Animations found: ${loadedAnimations.length}`);
      loadedAnimations.forEach((c, i) => console.log(`  [${i}] ${c.name} (${c.duration.toFixed(2)}s)`));

      // Compute scale + rotation once
      const box0 = new THREE.Box3().setFromObject(loadedModel);
      const size0 = box0.getSize(new THREE.Vector3());
      modelScale = 2.5 / size0.y;

      loadedModel.traverse(child => {
        if (child.isMesh) {
          child.material = new THREE.MeshBasicMaterial({ color: 0x33ff00, wireframe: true, transparent: true, opacity: 0.85 });
        }
      });

      // Auto-detect rotation
      {
        const testClone = SkeletonUtils.clone(loadedModel);
        testClone.scale.setScalar(modelScale);
        let bestScore = -Infinity;
        for (const tryRot of [0, Math.PI / 2, Math.PI, -Math.PI / 2]) {
          testClone.rotation.y = tryRot;
          testClone.updateMatrixWorld(true);
          const tb = new THREE.Box3().setFromObject(testClone);
          const tc = tb.getCenter(new THREE.Vector3());
          const ts = tb.getSize(new THREE.Vector3());
          if (ts.x < ts.z * 0.8) continue;
          let plusXMaxY = -Infinity, minusXMaxY = -Infinity;
          testClone.traverse(child => {
            if (child.isMesh) {
              const pos = child.geometry.attributes.position;
              const wp = new THREE.Vector3();
              child.updateMatrixWorld(true);
              for (let vi = 0; vi < pos.count; vi += 10) {
                wp.set(pos.getX(vi), pos.getY(vi), pos.getZ(vi));
                child.localToWorld(wp);
                if (wp.x > tc.x) plusXMaxY = Math.max(plusXMaxY, wp.y);
                else minusXMaxY = Math.max(minusXMaxY, wp.y);
              }
            }
          });
          const score = (plusXMaxY - minusXMaxY) + (ts.x - ts.z) * 0.1;
          if (score > bestScore) { bestScore = score; bestRotY = tryRot; }
        }
        console.log(`Auto-detected rotation: ${(bestRotY * 180 / Math.PI).toFixed(0)}`);
      }

      // Model loaded — show boot screen, wait for click to activate audio
      const pd = document.getElementById('phase-display');
      pd.style.display = 'none';

      const overlay = document.getElementById('start-overlay');
      const bootEl = document.getElementById('boot-lines');
      overlay.classList.remove('hidden');

      // Animate boot lines
      const bootMsgs = [
        ['> MOONAD BULL RACE v1.0', 'ok'],
        ['> gpu_renderer: ' + (renderer.info.render ? 'ACTIVE' : 'READY'), 'ok'],
        ['> bull_run: READY', 'ok'],
        ['> track_engine: READY', 'ok'],
        ['> betting_contract: ' + CONTRACT_ADDRESS.slice(0, 10) + '...', 'ok'],
      ];
      let bootIdx = 0;
      function showNextBoot() {
        if (bootIdx < bootMsgs.length) {
          const [msg, status] = bootMsgs[bootIdx];
          const line = document.createElement('div');
          line.innerHTML = `${msg} <span class="ok">[${status.toUpperCase()}]</span>`;
          bootEl.appendChild(line);
          bootIdx++;
          setTimeout(showNextBoot, 150);
        }
      }
      showNextBoot();

      // On click: activate audio → boot sound → LFG → start
      overlay.addEventListener('click', function startClick() {
        overlay.removeEventListener('click', startClick);
        overlay.querySelector('.start-prompt').textContent = '> INITIALIZING...';
        overlay.querySelector('.start-prompt').style.animation = 'none';

        // Activate audio + play boot sound
        SFX.bootUp();

        // After boot sound finishes, show LFG
        setTimeout(() => {
          overlay.classList.add('hidden');
          pd.style.display = 'block';
          pd.textContent = 'LFG!!!!';
          pd.classList.add('lfg');
          SFX.lfg();

          setTimeout(() => {
            pd.classList.remove('lfg');
            // Auto-sync to live phase on startup
            syncToLivePhase();
          }, 1500);
        }, 800);
      });

    }, (progress) => {
      if (progress.total > 0) {
        const pct = Math.min(100, Math.round(progress.loaded / progress.total * 100));
        document.getElementById('phase-display').textContent = `> loading_model [${pct}%]`;
      }
    }, (error) => {
      console.error('Error:', error);
      document.getElementById('phase-display').textContent = `> ERROR: ${error.message}_`;
    });

    // ======== LEADERBOARD ========
    function formatTime(s) {
      const m = Math.floor(s / 60);
      const sec = s % 60;
      return `${String(m).padStart(2, '0')}:${sec.toFixed(1).padStart(4, '0')}`;
    }

    function updateLeaderboard() {
      const sorted = [...bulls].sort((a, b) => {
        if (a.finished && b.finished) return a.finishRank - b.finishRank;
        if (a.finished) return -1;
        if (b.finished) return 1;
        return b.racePos - a.racePos;
      });
      const lb = document.getElementById('lb-body');
      lb.innerHTML = sorted.map((b, i) => {
        const medal = i === 0 ? ' <span class="medal">[1ST]</span>' : i === 1 ? ' <span class="medal">[2ND]</span>' : i === 2 ? ' <span class="medal">[3RD]</span>' : '';
        const fin = b.finished ? ' <span class="done">[OK]</span>' : '';
        const pct = Math.min(100, Math.max(0, (b.racePos / FINISH_X) * 100)).toFixed(0);
        const isMyBet = RM.myBet && bullColors.findIndex(c => c.name === b.name) === RM.myBet.bullIndex;
        return `<div class="lane"><span class="pos">${String(i + 1).padStart(2, '0')}.</span><span class="dot" style="background:${b.color}"></span><span class="name-text">${b.name}${isMyBet ? ' <-' : ''}</span>${medal}${fin} ${pct}%</div>`;
      }).join('');

      if (raceStarted) {
        const lead = sorted[0];
        const elapsed = clock.getElapsedTime() - raceStartTime;
        document.getElementById('clock-display').textContent = formatTime(elapsed);
        document.getElementById('speed-info').textContent = `SPD: ${lead.speed.toFixed(1)} M/S | ${lead.name}`;
      }
    }

    // ======== ANIMATION LOOP ========
    let camTrackX = 0, lastCamTrackX = 0;
    let cameraReady = false;
    const _camPos = new THREE.Vector3();
    const _camTgt = new THREE.Vector3();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);
      const elapsed = clock.getElapsedTime();

      // Phase timer
      if (RM.phase !== 'loading' && RM.phase !== 'racing') {
        updatePhaseTimer();
      }

      // Animate bull preview in betting panel
      updateBullPreview(dt);

      // ======== RACING PHASE ========
      if (bulls.length > 0 && raceStarted) {
        const raceTime = elapsed - raceStartTime;

        for (const bull of bulls) {
          if (bull.finished) {
            const t = elapsed - bull.finishTime;
            if (bull.finishRank === 1 && !bull.isWalking) {
              bull.racePos += bull.speed * 0.5 * dt;
              if (!bull.attackStarted) {
                bull.attackStarted = true;
                bull.runAction.fadeOut(0.4);
                bull.attackRunAction.reset().fadeIn(0.4).play();
              }
            } else if (t < bull.postDecel) {
              const moveSpeed = 2.0 + (bull.speed * 0.3) * (1 - t / bull.postDecel);
              bull.racePos += moveSpeed * dt;
              if (!bull.isWalking) {
                bull.isWalking = true;
                bull.runAction.fadeOut(0.8); bull.walkAction.reset().fadeIn(0.8).play();
              }
              bull.walkAction.timeScale = moveSpeed / 1.5;
            } else if (t < bull.postWalkEnd) {
              bull.isWalking = true;
              const progress = (t - bull.postDecel) / (bull.postWalkEnd - bull.postDecel);
              const moveSpeed = 1.8 * Math.max(0.1, 1 - progress * 0.8);
              bull.racePos += moveSpeed * dt;
              bull.walkAction.timeScale = moveSpeed / 1.5;
            } else if (!bull.isIdling) {
              bull.isIdling = true;
              bull.walkAction.fadeOut(1.0); bull.idleAction.reset().fadeIn(1.0).play();
            } else if (bull.finishRank !== 1 && t >= bull.postIdleEnd && !bull.isLying) {
              bull.isLying = true;
              bull.idleAction.fadeOut(0.8); bull.lieStartAction.reset().fadeIn(0.8).play();
            }
            bull.group.position.x = bull.racePos;
            if (bull.rankSprite) bull.rankSprite.position.x = bull.racePos;
            bull.mixer.update(dt);
            continue;
          }

          if (!bull.isRunning) {
            bull.isRunning = true;
            bull.runAction.timeScale = 0.8 + (bull.speed / 15) * 0.6;
            bull.idleAction.fadeOut(0.3); bull.runAction.reset().fadeIn(0.3).play();
          }

          const surge = Math.sin(raceTime * 1.5 + bull.phase) * 1.0 + Math.sin(raceTime * 0.5 + bull.phase * 2.3) * 0.6;
          const currentSpeed = Math.max(1.0, bull.speed + surge);
          bull.racePos += currentSpeed * dt;

          if (bull.racePos >= FINISH_X) {
            bull.finished = true;
            bull.finishTime = elapsed;
            bull.finishRank = nextRank++;
            if (bull.finishRank <= 3) {
              SFX.bullFinish();
              // Float rank label above the bull
              const rankSprite = createRankSprite(bull.finishRank, bull.color);
              rankSprite.position.set(bull.racePos, 4.2, bull.laneZ);
              scene.add(rankSprite);
              rankLabels.push(rankSprite);
              bull.rankSprite = rankSprite;
            }
            if (bull.finishRank === 1) {
              const finTime = elapsed - raceStartTime;
              const avgSpeed = (FINISH_X / finTime).toFixed(1);
              let photoURL = '';
              try {
                const photoRenderer = new THREE.WebGLRenderer({ antialias: true });
                photoRenderer.setSize(400, 300); photoRenderer.setPixelRatio(1);
                const photoCam = new THREE.PerspectiveCamera(40, 400 / 300, 0.1, 200);
                photoCam.position.set(bull.racePos + 4, 2.5, bull.laneZ + 5);
                photoCam.lookAt(bull.racePos, 1.2, bull.laneZ);
                photoRenderer.render(scene, photoCam);
                photoURL = photoRenderer.domElement.toDataURL('image/png');
                photoRenderer.dispose();
              } catch (e) { }
              const wd = document.getElementById('winner');
              const photoHtml = photoURL ? `<img id="winner-photo" src="${photoURL}" alt="${bull.name}">` : '';
              document.getElementById('winner-body').innerHTML =
                photoHtml +
                `<div class="stats">` +
                `> winner: <span class="name" style="color:${bull.color}">${bull.name}</span>\n` +
                `> time: ${formatTime(finTime)}\n` +
                `> avg_speed: ${avgSpeed} M/S\n` +
                `> rank: 1/${NUM_BULLS}</div>`;
              wd.style.display = 'block';
            }
            if (nextRank > NUM_BULLS) {
              raceOver = true;
              // Transition to results after a brief delay
              setTimeout(() => { if (RM.phase === 'racing') setPhase('results'); }, 3000);
            }
          }

          bull.group.position.x = bull.racePos;
          bull.mixer.update(dt);
          emitDust(bull.racePos - 1, 0, bull.laneZ, currentSpeed);
        }

        // Camera tracking
        const sorted = [...bulls].sort((a, b) => b.racePos - a.racePos);
        const leaderX = sorted[0].racePos;
        const middle = sorted[Math.floor(NUM_BULLS / 2)].racePos;
        const goalX = leaderX * 0.4 + middle * 0.6;
        camTrackX += (goalX - camTrackX) * 1.5 * dt;

        sun.position.x = camTrackX + 10;
        gridHelper.position.x = Math.round(camTrackX / 2) * 2;
        trackGrid.position.x = Math.round(camTrackX / 2) * 2;
        speedLines.position.x = camTrackX;

        if (raceOver) {
          controls.enabled = true;
        } else {
          controls.enabled = (camMode === 'free');
          if (camMode === 'free') {
            const dx = camTrackX - lastCamTrackX;
            camera.position.x += dx; controls.target.x += dx;
          } else {
            const lerpF = 1 - Math.exp(-5 * dt);
            if (camMode === 'chase') { _camPos.set(leaderX - 15, 5, 8); _camTgt.set(leaderX + 5, 1.2, 0); }
            else if (camMode === 'top') { _camPos.set(leaderX, 50, 0.01); _camTgt.set(leaderX, 0, 0); }
            else if (camMode === 'side') { _camPos.set(leaderX, 3, 20); _camTgt.set(leaderX, 1.2, 0); }
            else if (camMode === 'front') { _camPos.set(leaderX + 15, 3, 0); _camTgt.set(leaderX, 1.2, 0); }
            camera.position.lerp(_camPos, lerpF);
            controls.target.lerp(_camTgt, lerpF);
            camera.lookAt(controls.target);
          }
        }
        lastCamTrackX = camTrackX;

        if (Math.floor(elapsed * 4) !== Math.floor((elapsed - dt) * 4)) updateLeaderboard();
      }
      // ======== PRE-RACE: WALK IN ========
      else if (bulls.length > 0 && !raceStarted) {
        let allArrived = true;
        for (const bull of bulls) {
          if (!bull.arrived) {
            bull.racePos += bull.walkSpeed * dt;
            bull.walkAction.timeScale = bull.walkSpeed / 1.5;
            if (bull.racePos >= bull.startTarget) {
              bull.racePos = bull.startTarget;
              bull.arrived = true;
              bull.walkAction.fadeOut(0.6); bull.idleAction.reset().fadeIn(0.6).play();
            } else { allArrived = false; }
          }
          bull.group.position.x = bull.racePos;
          bull.mixer.update(dt);
        }

        // Pre-race camera
        controls.enabled = (camMode === 'free');
        const maxBullX = Math.max(...bulls.map(b => b.racePos));
        if (camMode === 'chase') { _camPos.set(maxBullX - 15, 5, 8); _camTgt.set(maxBullX + 5, 1.2, 0); }
        else if (camMode === 'top') { _camPos.set(maxBullX, 50, 0.01); _camTgt.set(maxBullX, 0, 0); }
        else if (camMode === 'side') { _camPos.set(maxBullX, 3, 20); _camTgt.set(maxBullX, 1.2, 0); }
        else if (camMode === 'front') { _camPos.set(maxBullX + 15, 3, 0); _camTgt.set(maxBullX, 1.2, 0); }
        if (camMode !== 'free') {
          if (!cameraReady) { camera.position.copy(_camPos); controls.target.copy(_camTgt); cameraReady = true; }
          else { const lf = 1 - Math.exp(-5 * dt); camera.position.lerp(_camPos, lf); controls.target.lerp(_camTgt, lf); }
          camera.lookAt(controls.target);
        } else if (!cameraReady) {
          camera.position.set(-12, 5, 8); controls.target.set(0, 1.2, 0); cameraReady = true;
        }
      }

      // Dust update
      for (let i = 0; i < dustCount; i++) {
        const v = dustVel[i];
        if (v.life > 0) {
          dustPos[i * 3] += v.x * dt; dustPos[i * 3 + 1] += v.y * dt; dustPos[i * 3 + 2] += v.z * dt;
          v.y -= dt * 0.4; v.life -= dt;
          if (v.life <= 0) dustPos[i * 3 + 1] = -10;
        }
      }
      dustGeo.attributes.position.needsUpdate = true;

      // WASD movement
      if (keysPressed.size > 0) {
        const spd = 25 * dt;
        const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
        const right = new THREE.Vector3().crossVectors(fwd, camera.up).normalize();
        const move = new THREE.Vector3();
        if (keysPressed.has('w') || keysPressed.has('arrowup')) move.addScaledVector(fwd, spd);
        if (keysPressed.has('s') || keysPressed.has('arrowdown')) move.addScaledVector(fwd, -spd);
        if (keysPressed.has('a') || keysPressed.has('arrowleft')) move.addScaledVector(right, -spd);
        if (keysPressed.has('d') || keysPressed.has('arrowright')) move.addScaledVector(right, spd);
        camera.position.add(move); controls.target.add(move);
      }

      // Animate rank label bobbing
      for (const lbl of rankLabels) {
        lbl.position.y = 4.2 + Math.sin(elapsed * 2 + lbl.position.z) * 0.15;
      }

      if (camMode === 'free') controls.update();
      renderer.render(scene, camera);
    }
    animate();

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
